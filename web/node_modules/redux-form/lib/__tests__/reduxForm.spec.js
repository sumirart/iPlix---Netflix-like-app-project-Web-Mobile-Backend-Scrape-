"use strict";

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _react = _interopRequireWildcard(require("react"));

var _testUtils = _interopRequireDefault(require("react-dom/test-utils"));

var _reactRedux = require("react-redux");

var _redux = require("redux");

var _reduxImmutablejs = require("redux-immutablejs");

var _actions = _interopRequireDefault(require("../actions"));

var _createField = _interopRequireDefault(require("../createField"));

var _createFieldArray = _interopRequireDefault(require("../createFieldArray"));

var _createReducer = _interopRequireDefault(require("../createReducer"));

var _createReduxForm = _interopRequireDefault(require("../createReduxForm"));

var _propTypes = _interopRequireDefault(require("../propTypes"));

var _FormSection = _interopRequireDefault(require("../FormSection"));

var _immutable = _interopRequireDefault(require("../structure/immutable"));

var _expectations = _interopRequireDefault(require("../structure/immutable/__tests__/expectations"));

var _plain = _interopRequireDefault(require("../structure/plain"));

var _expectations2 = _interopRequireDefault(require("../structure/plain/__tests__/expectations"));

var _SubmissionError = _interopRequireDefault(require("../SubmissionError"));

var _Form = _interopRequireDefault(require("../Form"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var change = _actions.default.change,
    clearSubmit = _actions.default.clearSubmit,
    initialize = _actions.default.initialize,
    setSubmitFailed = _actions.default.setSubmitFailed,
    setSubmitSucceeded = _actions.default.setSubmitSucceeded,
    startSubmit = _actions.default.startSubmit,
    stopSubmit = _actions.default.stopSubmit,
    submit = _actions.default.submit,
    touch = _actions.default.touch,
    updateSyncErrors = _actions.default.updateSyncErrors;

var propsAtNthRender = function propsAtNthRender(spy, callNumber) {
  return spy.mock.calls[callNumber][0];
};

var propsAtLastRender = function propsAtLastRender(spy) {
  return propsAtNthRender(spy, spy.mock.calls.length - 1);
};

var describeReduxForm = function describeReduxForm(name, structure, combineReducers, setup) {
  var fromJS = structure.fromJS,
      getIn = structure.getIn,
      setIn = structure.setIn;
  var reduxForm = (0, _createReduxForm.default)(structure);
  var Field = (0, _createField.default)(structure);
  var FieldArray = (0, _createFieldArray.default)(structure);
  var reducer = (0, _createReducer.default)(structure);
  describe(name, function () {
    beforeAll(function () {
      setup();
    });

    var makeStore = function makeStore(initial, logger) {
      if (initial === void 0) {
        initial = {};
      }

      var reducers = {
        form: reducer
      };

      if (logger) {
        reducers.logger = logger;
      }

      return (0, _redux.createStore)(combineReducers(reducers), fromJS({
        form: initial
      }));
    };

    var makeForm = function makeForm(renderSpy) {
      if (renderSpy === void 0) {
        renderSpy = _noop2.default;
      }

      return (
        /*#__PURE__*/
        function (_Component) {
          _inheritsLoose(Form, _Component);

          function Form() {
            return _Component.apply(this, arguments) || this;
          }

          var _proto = Form.prototype;

          _proto.render = function render() {
            renderSpy(this.props);
            return _react.default.createElement("div", null, _react.default.createElement(Field, {
              name: "foo",
              component: "input"
            }));
          };

          return Form;
        }(_react.Component)
      );
    };

    var renderForm = function renderForm(Form, formState, config, ref) {
      if (config === void 0) {
        config = {};
      }

      var store = makeStore({
        testForm: formState
      });
      var Decorated = reduxForm(_extends({
        form: 'testForm'
      }, config))(Form);
      return _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));
    };

    var propChecker = function propChecker(formState, renderSpy, config) {
      if (renderSpy === void 0) {
        renderSpy = _noop2.default;
      }

      if (config === void 0) {
        config = {};
      }

      var props;
      var Form = makeForm(function (p) {
        props = p;
        renderSpy(p);
      });
      renderForm(Form, formState, config);
      return props;
    };

    it('should return a decorator function', function () {
      expect(typeof reduxForm).toBe('function');
    });
    it('should render without error', function () {
      var store = makeStore();

      var Form =
      /*#__PURE__*/
      function (_Component2) {
        _inheritsLoose(Form, _Component2);

        function Form() {
          return _Component2.apply(this, arguments) || this;
        }

        var _proto2 = Form.prototype;

        _proto2.render = function render() {
          return _react.default.createElement("div", null);
        };

        return Form;
      }(_react.Component);

      expect(function () {
        var Decorated = reduxForm({
          form: 'testForm'
        })(Form);

        _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
          store: store
        }, _react.default.createElement(Decorated, null)));
      }).not.toThrow();
    });
    it('should update without error when there is no config', function () {
      var store = makeStore();

      var Form = function Form() {
        return _react.default.createElement("div", null);
      };

      var Decorated = reduxForm()(Form);

      var Container =
      /*#__PURE__*/
      function (_Component3) {
        _inheritsLoose(Container, _Component3);

        function Container(props) {
          var _this;

          _this = _Component3.call(this, props) || this;
          _this.state = {};
          return _this;
        }

        var _proto3 = Container.prototype;

        _proto3.render = function render() {
          var _this2 = this;

          return _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement("div", null, _react.default.createElement(Decorated, {
            form: "formname",
            foo: this.state.foo
          }), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this2.setState({
                foo: 'bar'
              });
            }
          })));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(function () {
        var button = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

        _testUtils.default.Simulate.click(button);
      }).not.toThrow();
    });
    it('should provide the correct props', function () {
      var props = propChecker({});
      expect(Object.keys(props).sort()).toEqual(['_reduxForm', 'anyTouched', 'array', 'asyncValidate', 'asyncValidating', 'autofill', 'blur', 'change', 'clearAsyncError', 'clearFields', 'clearSubmit', 'clearSubmitErrors', 'destroy', 'dirty', 'dispatch', 'error', 'form', 'handleSubmit', 'initialValues', 'initialize', 'initialized', 'invalid', 'pristine', 'pure', 'reset', 'resetSection', 'submit', 'submitFailed', 'submitSucceeded', 'submitting', 'touch', 'triggerSubmit', 'untouch', 'valid', 'warning']);
      expect(typeof props.anyTouched).toBe('boolean');
      expect(typeof props.array).toBe('object');
      expect(Object.keys(props.array).sort()).toEqual(['insert', 'move', 'pop', 'push', 'remove', 'removeAll', 'shift', 'splice', 'swap', 'unshift']);
      expect(typeof props.array.insert).toBe('function');
      expect(typeof props.array.move).toBe('function');
      expect(typeof props.array.pop).toBe('function');
      expect(typeof props.array.push).toBe('function');
      expect(typeof props.array.remove).toBe('function');
      expect(typeof props.array.removeAll).toBe('function');
      expect(typeof props.array.shift).toBe('function');
      expect(typeof props.array.splice).toBe('function');
      expect(typeof props.array.swap).toBe('function');
      expect(typeof props.array.unshift).toBe('function');
      expect(typeof props.asyncValidate).toBe('function');
      expect(typeof props.asyncValidating).toBe('boolean');
      expect(typeof props.autofill).toBe('function');
      expect(typeof props.blur).toBe('function');
      expect(typeof props.change).toBe('function');
      expect(typeof props.clearFields).toBe('function');
      expect(typeof props.destroy).toBe('function');
      expect(typeof props.dirty).toBe('boolean');
      expect(typeof props.form).toBe('string');
      expect(typeof props.handleSubmit).toBe('function');
      expect(typeof props.initialize).toBe('function');
      expect(typeof props.initialized).toBe('boolean');
      expect(typeof props.pristine).toBe('boolean');
      expect(typeof props.reset).toBe('function');
      expect(typeof props.resetSection).toBe('function');
      expect(typeof props.submitFailed).toBe('boolean');
      expect(typeof props.submitSucceeded).toBe('boolean');
      expect(typeof props.touch).toBe('function');
      expect(typeof props.untouch).toBe('function');
      expect(typeof props.valid).toBe('boolean');
    });
    it('should have declared all propTypes passed to decorated component', function () {
      var passedProps = Object.keys(propChecker({})).sort();
      var declaredPropTypes = Object.keys(_propTypes.default).concat('_reduxForm').sort();
      expect(passedProps).toEqual(declaredPropTypes);
    });
    describe('dirty prop', function () {
      it('should default `false`', function () {
        expect(propChecker({}).dirty).toBe(false);
      });
      it('should be `true` when `state.values` exists but `state.initial` does not exist', function () {
        expect(propChecker({
          // no initial values
          values: {
            foo: 'bar'
          }
        }).dirty).toBe(true);
      });
      it('should be `false` when `state.initial` equals `state.values`', function () {
        expect(propChecker({
          initial: {
            foo: 'bar'
          },
          values: {
            foo: 'bar'
          }
        }).dirty).toBe(false);
      });
      it('should be `true` when `state.initial` does not equal `state.values`', function () {
        expect(propChecker({
          initial: {
            foo: 'bar'
          },
          values: {
            foo: 'baz'
          }
        }).dirty).toBe(true);
      });
    });
    describe('pristine prop', function () {
      it('should default to `true`', function () {
        expect(propChecker({}).pristine).toBe(true);
      });
      it('should be `false` when `state.values` exists but `state.initial` does not exist', function () {
        expect(propChecker({
          // no initial values
          values: {
            foo: 'bar'
          }
        }).pristine).toBe(false);
      });
      it('should be `true` when `state.initial` equals `state.values`', function () {
        expect(propChecker({
          initial: {
            foo: 'bar'
          },
          values: {
            foo: 'bar'
          }
        }).pristine).toBe(true);
      });
      it('should be `false` when the `state.values` does not equal `state.initial`', function () {
        expect(propChecker({
          initial: {
            foo: 'bar'
          },
          values: {
            foo: 'baz'
          }
        }).pristine).toBe(false);
      });
    });
    describe('valid prop', function () {
      var checkValidPropGivenErrors = function checkValidPropGivenErrors(errors, expectation) {
        // Check Sync Errors
        expect(propChecker({}, undefined, {
          validate: function validate() {
            return errors;
          }
        }).valid).toBe(expectation); // Check Async Errors

        expect(propChecker({
          asyncErrors: errors
        }).valid).toBe(expectation);
      };

      it('should default to `true`', function () {
        checkValidPropGivenErrors({}, true);
      });
      it('should be `false` when `errors` has a `string` property', function () {
        checkValidPropGivenErrors({
          foo: 'bar'
        }, false);
      });
      it('should be `false` when `errors` has a `number` property', function () {
        checkValidPropGivenErrors({
          foo: 42
        }, false);
      });
      it('should be `true` when `errors` has an `undefined` property', function () {
        checkValidPropGivenErrors({
          foo: undefined
        }, true);
      });
      it('should be `true` when `errors` has a `null` property', function () {
        checkValidPropGivenErrors({
          foo: null
        }, true);
      });
      it('should be `true` when `errors` has an empty array', function () {
        checkValidPropGivenErrors({
          myArrayField: []
        }, true);
      });
      it('should be `true` when `errors` has an array with only `undefined` values', function () {
        checkValidPropGivenErrors({
          myArrayField: [undefined, undefined]
        }, true);
      });
      it('should be `true` when `errors` has an array containing strings', function () {
        // Note: I didn't write the isValid, but my intuition tells me this seems incorrect. â€“ ncphillips
        checkValidPropGivenErrors({
          myArrayField: ['baz']
        }, true);
      });
    });
    describe('invalid prop', function () {
      var checkInvalidPropGivenErrors = function checkInvalidPropGivenErrors(errors, expectation) {
        // Check Sync Errors
        expect(propChecker({}, undefined, {
          validate: function validate() {
            return errors;
          }
        }).invalid).toBe(expectation); // Check Async Errors

        expect(propChecker({
          asyncErrors: errors
        }).invalid).toBe(expectation);
      };

      it('should default to `false`', function () {
        checkInvalidPropGivenErrors({}, false);
      });
      it('should be `true` when errors has a `string` propertry', function () {
        checkInvalidPropGivenErrors({
          foo: 'sync error'
        }, true);
      });
      it('should be `true` when errors has a `number` property', function () {
        checkInvalidPropGivenErrors({
          foo: 12
        }, true);
      });
      it('should be `false` when errors has only an `undefined` property', function () {
        checkInvalidPropGivenErrors({
          foo: undefined
        }, false);
      });
      it('should be `false` when errors has only a `null` property', function () {
        checkInvalidPropGivenErrors({
          foo: null
        }, false);
      });
      it('should be `false` when errors has only an empty array', function () {
        checkInvalidPropGivenErrors({
          myArrayField: []
        }, false);
      });
    });
    it('should provide submitting prop', function () {
      expect(propChecker({}).submitting).toBe(false);
      expect(propChecker({
        submitting: true
      }).submitting).toBe(true);
      expect(propChecker({
        submitting: false
      }).submitting).toBe(false);
    });
    it('should put props under prop namespace if specified', function () {
      var props = propChecker({}, _noop2.default, {
        propNamespace: 'fooProps',
        someOtherProp: 'whatever'
      });
      expect(typeof props.fooProps).toBe('object');
      expect(props.dispatch).toBeFalsy();
      expect(props.dirty).toBeFalsy();
      expect(props.pristine).toBeFalsy();
      expect(props.submitting).toBeFalsy();
      expect(props.someOtherProp).toBeTruthy();
      expect(typeof props.fooProps.dispatch).toBe('function');
      expect(typeof props.fooProps.dirty).toBe('boolean');
      expect(typeof props.fooProps.pristine).toBe('boolean');
      expect(typeof props.fooProps.submitting).toBe('boolean');
      expect(typeof props.fooProps.array).toBe('object');
      expect(props.fooProps.someOtherProp).toBeFalsy();
    });
    it('should provide bound array action creators', function () {
      var arrayProp = propChecker({}).array;
      expect(arrayProp).toBeTruthy();
      expect(typeof arrayProp.insert).toBe('function');
      expect(typeof arrayProp.pop).toBe('function');
      expect(typeof arrayProp.push).toBe('function');
      expect(typeof arrayProp.remove).toBe('function');
      expect(typeof arrayProp.shift).toBe('function');
      expect(typeof arrayProp.splice).toBe('function');
      expect(typeof arrayProp.swap).toBe('function');
      expect(typeof arrayProp.unshift).toBe('function');
    });
    it('should not rerender unless form-wide props (except value!) change', function () {
      var spy = jest.fn();

      var _propChecker = propChecker({}, spy, {
        validate: function validate(values) {
          var foo = getIn(values, 'foo');
          return foo && foo.length > 5 ? {
            foo: 'Too long'
          } : {};
        }
      }),
          dispatch = _propChecker.dispatch; // render 0


      expect(spy).toHaveBeenCalledTimes(1); // simulate typing the word "giraffe"

      dispatch(change('testForm', 'foo', 'g')); // render 1 (now dirty)

      expect(spy).toHaveBeenCalledTimes(2);
      dispatch(change('testForm', 'foo', 'gi')); // no render

      dispatch(change('testForm', 'foo', 'gir')); // no render

      dispatch(change('testForm', 'foo', 'gira')); // no render

      dispatch(change('testForm', 'foo', 'giraf')); // no render

      dispatch(change('testForm', 'foo', 'giraff')); // render 2 (invalid)

      expect(spy).toHaveBeenCalledTimes(3);
      dispatch(change('testForm', 'foo', 'giraffe')); // no render

      dispatch(change('testForm', 'foo', '')); // render 3 (clean/valid)

      expect(spy).toHaveBeenCalledTimes(5); // two renders, one to change value, and other to revalidate

      expect(propsAtNthRender(spy, 0).dirty).toBe(false);
      expect(propsAtNthRender(spy, 0).invalid).toBe(false);
      expect(propsAtNthRender(spy, 0).pristine).toBe(true);
      expect(propsAtNthRender(spy, 0).valid).toBe(true);
      expect(propsAtNthRender(spy, 1).dirty).toBe(true);
      expect(propsAtNthRender(spy, 1).invalid).toBe(false);
      expect(propsAtNthRender(spy, 1).pristine).toBe(false);
      expect(propsAtNthRender(spy, 1).valid).toBe(true);
      expect(propsAtNthRender(spy, 2).dirty).toBe(true);
      expect(propsAtNthRender(spy, 2).invalid).toBe(true);
      expect(propsAtNthRender(spy, 2).pristine).toBe(false);
      expect(propsAtNthRender(spy, 2).valid).toBe(false);
      expect(propsAtNthRender(spy, 4).dirty).toBe(false);
      expect(propsAtNthRender(spy, 4).invalid).toBe(false);
      expect(propsAtNthRender(spy, 4).pristine).toBe(true);
      expect(propsAtNthRender(spy, 4).valid).toBe(true);
    });
    it('should rerender on every change if pure is false', function () {
      var spy = jest.fn();

      var _propChecker2 = propChecker({}, spy, {
        pure: false
      }),
          dispatch = _propChecker2.dispatch;

      expect(spy).toHaveBeenCalledTimes(2); // twice, second one is for after field registration
      // simulate typing the word "giraffe"

      dispatch(change('testForm', 'foo', 'g'));
      expect(spy).toHaveBeenCalledTimes(3);
      dispatch(change('testForm', 'foo', 'gi'));
      expect(spy).toHaveBeenCalledTimes(4);
      dispatch(change('testForm', 'foo', 'gir'));
      expect(spy).toHaveBeenCalledTimes(5);
      dispatch(change('testForm', 'foo', 'gira'));
      expect(spy).toHaveBeenCalledTimes(6);
      dispatch(change('testForm', 'foo', 'giraf'));
      expect(spy).toHaveBeenCalledTimes(7);
      dispatch(change('testForm', 'foo', 'giraff'));
      expect(spy).toHaveBeenCalledTimes(8);
      dispatch(change('testForm', 'foo', 'giraffe'));
      expect(spy).toHaveBeenCalledTimes(9);
    });
    it('should strict equals props in immutableProps', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component4) {
        _inheritsLoose(Form, _Component4);

        function Form() {
          return _Component4.apply(this, arguments) || this;
        }

        var _proto4 = Form.prototype;

        _proto4.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        immutableProps: ['foo']
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component5) {
        _inheritsLoose(Container, _Component5);

        function Container(props) {
          var _this3;

          _this3 = _Component5.call(this, props) || this;
          _this3.state = {
            foo: {
              get no() {
                throw new Error('props inside an immutableProps object should not be looked at');
              }

            }
          };
          return _this3;
        }

        var _proto5 = Container.prototype;

        _proto5.render = function render() {
          var _this4 = this;

          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, _extends({}, this.state, {
            foo: this.state.foo
          }))), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this4.setState({
                foo: {
                  no: undefined
                }
              });
            }
          }, "Init"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(1); // initialize

      var initButton = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(initButton);

      expect(formRender).toHaveBeenCalledTimes(2);
      expect(inputRender).toHaveBeenCalledTimes(1);
    });
    it('should set checkbox values to false when unchecked', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", _extends({}, props.input, {
          type: "checkbox"
        }));
      });
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component6) {
        _inheritsLoose(Form, _Component6);

        function Form() {
          return _Component6.apply(this, arguments) || this;
        }

        var _proto6 = Form.prototype;

        _proto6.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender,
            type: "checkbox"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      var checkbox = _testUtils.default.scryRenderedDOMComponentsWithTag(dom, 'input').find(function (element) {
        return element.getAttribute('name') === 'foo';
      });

      expect(formRender).toHaveBeenCalledTimes(1);
      expect(inputRender).toHaveBeenCalledTimes(1);
      expect(getIn(store.getState(), 'form.testForm.values.foo')).toBeFalsy();
      expect(propsAtNthRender(inputRender, 0).input.checked).toBe(false);

      _testUtils.default.Simulate.change(checkbox, {
        target: {
          type: 'checkbox',
          checked: true
        }
      });

      expect(inputRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(inputRender, 1).input.checked).toBe(true);
      expect(getIn(store.getState(), 'form.testForm.values.foo')).toBe(true);

      _testUtils.default.Simulate.change(checkbox, {
        target: {
          type: 'checkbox',
          checked: false
        }
      });

      expect(inputRender).toHaveBeenCalledTimes(3);
      expect(propsAtNthRender(inputRender, 2).input.value).toBe(false);
      expect(getIn(store.getState(), 'form.testForm.values.foo')).toBe(false);
    });
    it('should set checkbox values to false when unchecked (when initialized)', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", _extends({}, props.input, {
          type: "checkbox"
        }));
      });
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component7) {
        _inheritsLoose(Form, _Component7);

        function Form() {
          return _Component7.apply(this, arguments) || this;
        }

        var _proto7 = Form.prototype;

        _proto7.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender,
            type: "checkbox"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        initialValues: {
          foo: true
        }
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      var checkbox = _testUtils.default.scryRenderedDOMComponentsWithTag(dom, 'input').find(function (element) {
        return element.getAttribute('name') === 'foo';
      });

      expect(formRender).toHaveBeenCalledTimes(2);
      expect(inputRender).toHaveBeenCalledTimes(2);
      expect(getIn(store.getState(), 'form.testForm.values.foo')).toBe(true);
      expect(propsAtNthRender(inputRender, 1).input.checked).toBe(true);

      _testUtils.default.Simulate.change(checkbox, {
        target: {
          type: 'checkbox',
          checked: false
        }
      });

      expect(inputRender).toHaveBeenCalledTimes(3);
      expect(propsAtNthRender(inputRender, 2).input.checked).toBe(false);
      expect(getIn(store.getState(), 'form.testForm.values.foo')).toBe(false);

      _testUtils.default.Simulate.change(checkbox, {
        target: {
          type: 'checkbox',
          checked: true
        }
      });

      expect(inputRender).toHaveBeenCalledTimes(4);
      expect(propsAtNthRender(inputRender, 3).input.value).toBe(true);
      expect(getIn(store.getState(), 'form.testForm.values.foo')).toBe(true);
    });
    it('should initialize values with initialValues on first render', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues = {
        deep: {
          foo: 'bar'
        }
      };

      var Form =
      /*#__PURE__*/
      function (_Component8) {
        _inheritsLoose(Form, _Component8);

        function Form() {
          return _Component8.apply(this, arguments) || this;
        }

        var _proto8 = Form.prototype;

        _proto8.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        initialValues: initialValues
      })));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            initial: initialValues,
            values: initialValues,
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);

      var checkProps = function checkProps(props) {
        expect(props.pristine).toBe(true);
        expect(props.dirty).toBe(false);
        expect(props.initialized).toBe(true);
        expect(props.initialValues).toEqualMap(initialValues);
      };

      checkProps(propsAtNthRender(formRender, 1));
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(inputRender, 1).meta.pristine).toBe(true);
      expect(propsAtNthRender(inputRender, 1).meta.dirty).toBe(false);
      expect(propsAtNthRender(inputRender, 1).input.value).toBe('bar');
    });
    it('should support calling change in Form componentDidMount', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues = {
        deep: {
          foo: 'bar'
        }
      };

      var Form =
      /*#__PURE__*/
      function (_Component9) {
        _inheritsLoose(Form, _Component9);

        function Form() {
          return _Component9.apply(this, arguments) || this;
        }

        var _proto9 = Form.prototype;

        _proto9.componentDidMount = function componentDidMount() {
          this.props.change('deep.foo', 'baz');
        };

        _proto9.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        initialValues: initialValues
      })));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            initial: initialValues,
            values: {
              deep: {
                foo: 'baz'
              }
            },
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);

      var checkProps = function checkProps(props) {
        expect(props.pristine).toBe(false);
        expect(props.dirty).toBe(true);
        expect(props.initialized).toBe(true);
        expect(props.initialValues).toEqualMap(initialValues);
      };

      checkProps(propsAtNthRender(formRender, 1));
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(2); // should be dirty on second render, after change completes

      expect(propsAtNthRender(inputRender, 1).meta.pristine).toBe(false);
      expect(propsAtNthRender(inputRender, 1).meta.dirty).toBe(true);
      expect(propsAtNthRender(inputRender, 1).input.value).toBe('baz');
    });
    it('should initialize with initialValues on later render if not already initialized', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues = {
        deep: {
          foo: 'bar'
        }
      };

      var Form =
      /*#__PURE__*/
      function (_Component10) {
        _inheritsLoose(Form, _Component10);

        function Form() {
          return _Component10.apply(this, arguments) || this;
        }

        var _proto10 = Form.prototype;

        _proto10.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component11) {
        _inheritsLoose(Container, _Component11);

        function Container(props) {
          var _this5;

          _this5 = _Component11.call(this, props) || this;
          _this5.state = {};
          return _this5;
        }

        var _proto11 = Container.prototype;

        _proto11.render = function render() {
          var _this6 = this;

          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, this.state)), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this6.setState({
                initialValues: initialValues
              });
            }
          }, "Init"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(1);

      var checkInputProps = function checkInputProps(props, value) {
        expect(props.meta.pristine).toBe(true);
        expect(props.meta.dirty).toBe(false);
        expect(props.input.value).toBe(value);
      };

      checkInputProps(inputRender.mock.calls[0][0], ''); // initialize

      var initButton = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(initButton); // check initialized state


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues,
            values: initialValues
          }
        }
      }); // no need to rerender form on initialize

      expect(formRender).toHaveBeenCalledTimes(2); // check rerendered input

      expect(inputRender).toHaveBeenCalledTimes(2);
      checkInputProps(inputRender.mock.calls[1][0], 'bar');
    });
    it('should NOT reinitialize with initialValues', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues1 = {
        deep: {
          foo: 'bar'
        }
      };
      var initialValues2 = {
        deep: {
          foo: 'baz'
        }
      };

      var Form =
      /*#__PURE__*/
      function (_Component12) {
        _inheritsLoose(Form, _Component12);

        function Form() {
          return _Component12.apply(this, arguments) || this;
        }

        var _proto12 = Form.prototype;

        _proto12.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component13) {
        _inheritsLoose(Container, _Component13);

        function Container(props) {
          var _this7;

          _this7 = _Component13.call(this, props) || this;
          _this7.state = {
            initialValues: initialValues1
          };
          return _this7;
        }

        var _proto13 = Container.prototype;

        _proto13.render = function render() {
          var _this8 = this;

          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, this.state)), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this8.setState({
                initialValues: initialValues2
              });
            }
          }, "Init"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues1,
            values: initialValues1
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(2);

      var checkInputProps = function checkInputProps(props, value) {
        expect(props.meta.pristine).toBe(true);
        expect(props.meta.dirty).toBe(false);
        expect(props.input.value).toBe(value);
      };

      checkInputProps(inputRender.mock.calls[1][0], 'bar'); // initialize

      var initButton = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(initButton); // check initialized state


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues1,
            values: initialValues1
          }
        }
      }); // rerender just because prop changed

      expect(formRender).toHaveBeenCalledTimes(2); // no need to rerender input since nothing changed

      expect(inputRender).toHaveBeenCalledTimes(2);
    });
    it('should reinitialize with initialValues if enableReinitialize', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues1 = {
        deep: {
          foo: 'bar'
        }
      };
      var initialValues2 = {
        deep: {
          foo: 'baz'
        }
      };

      var Form =
      /*#__PURE__*/
      function (_Component14) {
        _inheritsLoose(Form, _Component14);

        function Form() {
          return _Component14.apply(this, arguments) || this;
        }

        var _proto14 = Form.prototype;

        _proto14.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        enableReinitialize: true
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component15) {
        _inheritsLoose(Container, _Component15);

        function Container(props) {
          var _this9;

          _this9 = _Component15.call(this, props) || this;
          _this9.state = {
            initialValues: initialValues1
          };
          return _this9;
        }

        var _proto15 = Container.prototype;

        _proto15.render = function render() {
          var _this10 = this;

          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, this.state)), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this10.setState({
                initialValues: initialValues2
              });
            }
          }, "Init"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      var checkInputProps = function checkInputProps(props, value, pristine, dirty) {
        if (pristine === void 0) {
          pristine = true;
        }

        if (dirty === void 0) {
          dirty = false;
        }

        expect(props.meta.pristine).toBe(pristine);
        expect(props.meta.dirty).toBe(dirty);
        expect(props.input.value).toBe(value);
      }; // Check initial state


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues1,
            values: initialValues1
          }
        }
      }); // Expect renders due to initialization.

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(2); // Expect that input value has been initialized

      checkInputProps(inputRender.mock.calls[1][0], 'bar'); // Change input value and check if it is dirty and not pristine

      var onChange = inputRender.mock.calls[1][0].input.onChange;
      onChange('dirtyvalue'); // Expect rerenders due to the change.

      expect(formRender).toHaveBeenCalledTimes(3);
      expect(inputRender).toHaveBeenCalledTimes(3); // Expect that input value has been changed and is dirty now

      checkInputProps(inputRender.mock.calls[2][0], 'dirtyvalue', false, true); // Re-initialize form and check if it is pristine and not dirty

      var initButton = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(initButton); // Check re-initialized state


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues2,
            values: initialValues2
          }
        }
      }); // Expect rerenders due to the re-initialization.

      expect(formRender).toHaveBeenCalledTimes(4);
      expect(inputRender).toHaveBeenCalledTimes(4); // Expect that input value has been re-initialized and is not dirty anymore

      checkInputProps(inputRender.mock.calls[3][0], 'baz');
    });
    it('should retain dirty fields if keepDirtyOnReinitialize is set', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues1 = {
        deep: {
          foo: 'bar'
        }
      };
      var initialValues2 = {
        deep: {
          foo: 'baz'
        }
      };

      var Form =
      /*#__PURE__*/
      function (_Component16) {
        _inheritsLoose(Form, _Component16);

        function Form() {
          return _Component16.apply(this, arguments) || this;
        }

        var _proto16 = Form.prototype;

        _proto16.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        enableReinitialize: true,
        keepDirtyOnReinitialize: true
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component17) {
        _inheritsLoose(Container, _Component17);

        function Container(props) {
          var _this11;

          _this11 = _Component17.call(this, props) || this;
          _this11.state = {
            initialValues: initialValues1
          };
          return _this11;
        }

        var _proto17 = Container.prototype;

        _proto17.render = function render() {
          var _this12 = this;

          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, this.state)), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this12.setState({
                initialValues: initialValues2
              });
            }
          }, "Init"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues1,
            values: initialValues1
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(2);

      var checkInputProps = function checkInputProps(props, value, dirty) {
        expect(props.meta.pristine).toBe(!dirty);
        expect(props.meta.dirty).toBe(dirty);
        expect(props.input.value).toBe(value);
      };

      checkInputProps(inputRender.mock.calls[1][0], 'bar', false); // Change the input value.

      var onChange = inputRender.mock.calls[1][0].input.onChange;
      onChange('dirtyvalue'); // Expect rerenders due to the change.

      expect(formRender).toHaveBeenCalledTimes(3);
      expect(inputRender).toHaveBeenCalledTimes(3); // Reinitialize the form

      var initButton = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(initButton); // check initialized state


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues2,
            values: {
              deep: {
                foo: 'dirtyvalue'
              }
            }
          }
        }
      }); // Expect the form not to rerender, since the value did not change.

      expect(formRender).toHaveBeenCalledTimes(3); // should rerender input with the dirty value and new meta.initial

      expect(inputRender).toHaveBeenCalledTimes(4);
      checkInputProps(inputRender.mock.calls[2][0], 'dirtyvalue', true);
      checkInputProps(inputRender.mock.calls[3][0], 'dirtyvalue', true);
    });
    it('should not retain dirty fields if keepDirtyOnReinitialize is not set', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues1 = {
        deep: {
          foo: 'bar'
        }
      };
      var initialValues2 = {
        deep: {
          foo: 'baz'
        }
      };

      var Form =
      /*#__PURE__*/
      function (_Component18) {
        _inheritsLoose(Form, _Component18);

        function Form() {
          return _Component18.apply(this, arguments) || this;
        }

        var _proto18 = Form.prototype;

        _proto18.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        enableReinitialize: true
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component19) {
        _inheritsLoose(Container, _Component19);

        function Container(props) {
          var _this13;

          _this13 = _Component19.call(this, props) || this;
          _this13.state = {
            initialValues: initialValues1
          };
          return _this13;
        }

        var _proto19 = Container.prototype;

        _proto19.render = function render() {
          var _this14 = this;

          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, this.state)), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this14.setState({
                initialValues: initialValues2
              });
            }
          }, "Init"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues1,
            values: initialValues1
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(2);

      var checkInputProps = function checkInputProps(props, value, dirty) {
        expect(props.meta.pristine).toBe(!dirty);
        expect(props.meta.dirty).toBe(dirty);
        expect(props.input.value).toBe(value);
      };

      checkInputProps(inputRender.mock.calls[1][0], 'bar', false); // Change the input value.

      var onChange = inputRender.mock.calls[1][0].input.onChange;
      onChange('dirtyvalue'); // Expect rerenders due to the change.

      expect(formRender).toHaveBeenCalledTimes(3);
      expect(inputRender).toHaveBeenCalledTimes(3); // Reinitialize the form

      var initButton = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(initButton); // check initialized state


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues2,
            values: initialValues2
          }
        }
      }); // Expect the form to rerender, since the value was replaced.

      expect(formRender).toHaveBeenCalledTimes(4); // should rerender input with the pristine value.

      expect(inputRender).toHaveBeenCalledTimes(4);
      checkInputProps(inputRender.mock.calls[3][0], 'baz', false);
    });
    it('should be pristine after initialize() if enableReinitialize', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues1 = {
        deep: {
          foo: 'bar'
        }
      };

      var Form =
      /*#__PURE__*/
      function (_Component20) {
        _inheritsLoose(Form, _Component20);

        function Form() {
          return _Component20.apply(this, arguments) || this;
        }

        var _proto20 = Form.prototype;

        _proto20.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        enableReinitialize: true
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component21) {
        _inheritsLoose(Container, _Component21);

        function Container(props) {
          var _this15;

          _this15 = _Component21.call(this, props) || this;
          _this15.state = {
            initialValues: initialValues1
          };
          return _this15;
        }

        var _proto21 = Container.prototype;

        _proto21.render = function render() {
          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, this.state)));
        };

        return Container;
      }(_react.Component);

      _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      propsAtLastRender(inputRender).input.onChange('newBar');
      expect(propsAtLastRender(inputRender).input.value).toBe('newBar');
      expect(propsAtLastRender(inputRender).meta.pristine).toBe(false);
      expect(propsAtLastRender(formRender).pristine).toBe(false);
      store.dispatch(initialize('testForm', {
        deep: {
          foo: 'baz'
        }
      }));
      expect(propsAtLastRender(inputRender).input.value).toBe('baz');
      expect(propsAtLastRender(inputRender).meta.pristine).toBe(true);
      expect(propsAtLastRender(formRender).pristine).toBe(true);
    });
    it('should have initialized prop after initialization from initialValues config', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues = {
        foo: 'bar'
      };

      var Form =
      /*#__PURE__*/
      function (_Component22) {
        _inheritsLoose(Form, _Component22);

        function Form() {
          return _Component22.apply(this, arguments) || this;
        }

        var _proto22 = Form.prototype;

        _proto22.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        initialValues: initialValues
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2); // initial + after initialize

      expect(propsAtNthRender(formRender, 1).initialized).toBe(true);
    });
    it('should have initialized prop after initialization from initialize()', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues = {
        foo: 'bar'
      };

      var Form =
      /*#__PURE__*/
      function (_Component23) {
        _inheritsLoose(Form, _Component23);

        function Form() {
          return _Component23.apply(this, arguments) || this;
        }

        var _proto23 = Form.prototype;

        _proto23.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(propsAtNthRender(formRender, 0).initialized).toBe(false); // initialize with action

      propsAtNthRender(formRender, 0).initialize(initialValues); // check initialized prop

      expect(formRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(formRender, 1).initialized).toBe(true);
    });
    it('should make pristine any dirty field that has the new initial value, when keepDirtyOnReinitialize', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues1 = {
        deep: {
          foo: 'bar'
        }
      };
      var initialValues2 = {
        deep: {
          foo: 'futurevalue'
        }
      };

      var Form =
      /*#__PURE__*/
      function (_Component24) {
        _inheritsLoose(Form, _Component24);

        function Form() {
          return _Component24.apply(this, arguments) || this;
        }

        var _proto24 = Form.prototype;

        _proto24.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        enableReinitialize: true,
        keepDirtyOnReinitialize: true
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component25) {
        _inheritsLoose(Container, _Component25);

        function Container(props) {
          var _this16;

          _this16 = _Component25.call(this, props) || this;
          _this16.state = {
            initialValues: initialValues1
          };
          return _this16;
        }

        var _proto25 = Container.prototype;

        _proto25.render = function render() {
          var _this17 = this;

          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, this.state)), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this17.setState({
                initialValues: initialValues2
              });
            }
          }, "Init"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues1,
            values: initialValues1
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(2);

      var checkInputProps = function checkInputProps(props, value, dirty) {
        expect(props.meta.pristine).toBe(!dirty);
        expect(props.meta.dirty).toBe(dirty);
        expect(props.input.value).toBe(value);
      };

      checkInputProps(inputRender.mock.calls[1][0], 'bar', false); // Change the input value.

      var onChange = inputRender.mock.calls[1][0].input.onChange;
      onChange('futurevalue'); // Expect rerenders due to the change.

      expect(formRender).toHaveBeenCalledTimes(3);
      expect(inputRender).toHaveBeenCalledTimes(3); // Reinitialize the form

      var initButton = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(initButton); // check initialized state


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues2,
            values: initialValues2
          }
        }
      }); // Expect the form to rerender only once more because the value did
      // not change.

      expect(formRender).toHaveBeenCalledTimes(4); // should rerender input with the new value that is now pristine.

      expect(inputRender).toHaveBeenCalledTimes(4);
      checkInputProps(inputRender.mock.calls[3][0], 'futurevalue', false);
    }); // Test related to #1436

    /*
     it('should allow initialization via action to set pristine', () => {
     const store = makeStore({})
     const inputRender = createSpy(props => <input {...props.input}/>).andCallThrough()
     const formRender = createSpy()
     const initialValues1 = {
     deep: {
     foo: 'bar'
     }
     }
     const initialValues2 = {
     deep: {
     foo: 'baz'
     }
     }
      class Form extends Component {
     render() {
     formRender(this.props)
     return (
     <form>
     <Field name="deep.foo" component={inputRender} type="text"/>
     </form>
     )
     }
     }
     const Decorated = reduxForm({
     form: 'testForm',
     initialValues: initialValues1
     })(Form)
      TestUtils.renderIntoDocument(
     <Provider store={store}>
     <Decorated/>
     </Provider>
     )
     expect(store.getState()).toEqualMap({
     form: {
     testForm: {
     registeredFields: { 'deep.foo': { name: 'deep.foo', type: 'Field', count: 1 } },
     initial: initialValues1,
     values: initialValues1
     }
     }
     })
     expect(formRender).toHaveBeenCalled()
     expect(formRender.calls.length).toBe(1)
     expect(propsAtNthRender(formRender, 0).pristine).toBe(true)
      expect(inputRender).toHaveBeenCalled()
     expect(inputRender.calls.length).toBe(1)
     expect(propsAtNthRender(inputRender, 0).meta.pristine).toBe(true)
     expect(propsAtNthRender(inputRender, 0).input.value).toBe('bar')
      // check initialized state
     expect(store.getState()).toEqualMap({
     form: {
     testForm: {
     registeredFields: {
     'deep.foo': { name: 'deep.foo', type: 'Field', count: 1 }
     },
     initial: initialValues1,
     values: initialValues1
     }
     }
     })
      // initialize with action
     store.dispatch(initialize('testForm', initialValues2))
      // check initialized state
     expect(store.getState()).toEqualMap({
     form: {
     testForm: {
     registeredFields: {
     'deep.foo': { name: 'deep.foo', type: 'Field', count: 1 }
     },
     initial: initialValues2,
     values: initialValues2
     }
     }
     })
      // rerendered
     expect(formRender.calls.length).toBe(2)
     expect(propsAtNthRender(formRender, 1).pristine).toBe(true)
      expect(inputRender).toHaveBeenCalled()
     expect(inputRender.calls.length).toBe(2)
     expect(propsAtNthRender(inputRender, 1).meta.pristine).toBe(true)
     expect(propsAtNthRender(inputRender, 1).input.value).toBe('baz')
     })
     */

    it('should destroy on unmount by default', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component26) {
        _inheritsLoose(Form, _Component26);

        function Form() {
          return _Component26.apply(this, arguments) || this;
        }

        var _proto26 = Form.prototype;

        _proto26.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component27) {
        _inheritsLoose(Container, _Component27);

        function Container(props) {
          var _this18;

          _this18 = _Component27.call(this, props) || this;
          _this18.state = {
            showForm: true
          };
          return _this18;
        }

        var _proto27 = Container.prototype;

        _proto27.render = function render() {
          var _this19 = this;

          var showForm = this.state.showForm;
          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement("div", null, showForm && _react.default.createElement(Decorated, this.state))), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this19.setState({
                showForm: !showForm
              });
            }
          }, "Toggle"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }, 'Form data in Redux did not get destroyed');
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(1);
      expect(propsAtNthRender(inputRender, 0).input.value).toBe(''); // change field

      inputRender.mock.calls[0][0].input.onChange('bob'); // form rerenders because now dirty

      expect(formRender).toHaveBeenCalledTimes(2); // input now has value

      expect(inputRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(inputRender, 1).input.value).toBe('bob'); // check state

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            values: {
              deep: {
                foo: 'bob'
              }
            },
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }); // unmount form

      var toggle = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(toggle); // check clean state


      expect(store.getState()).toEqualMap({
        form: {}
      }); // form still not rendered again

      expect(formRender).toHaveBeenCalledTimes(2); // toggle form back into existence

      _testUtils.default.Simulate.click(toggle); // form is back


      expect(formRender).toHaveBeenCalledTimes(3); // input is back, but without value

      expect(inputRender).toHaveBeenCalledTimes(3);
      expect(propsAtNthRender(inputRender, 2).input.value).toBe('');
    });
    it('should not destroy on unmount if told not to', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component28) {
        _inheritsLoose(Form, _Component28);

        function Form() {
          return _Component28.apply(this, arguments) || this;
        }

        var _proto28 = Form.prototype;

        _proto28.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        destroyOnUnmount: false
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component29) {
        _inheritsLoose(Container, _Component29);

        function Container(props) {
          var _this20;

          _this20 = _Component29.call(this, props) || this;
          _this20.state = {
            showForm: true
          };
          return _this20;
        }

        var _proto29 = Container.prototype;

        _proto29.render = function render() {
          var _this21 = this;

          var showForm = this.state.showForm;
          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement("div", null, showForm && _react.default.createElement(Decorated, this.state))), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this21.setState({
                showForm: !showForm
              });
            }
          }, "Toggle"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }, 'Form data in Redux did not get destroyed');
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(1);
      expect(propsAtNthRender(inputRender, 0).input.value).toBe(''); // change field

      inputRender.mock.calls[0][0].input.onChange('bob'); // form rerenders because now dirty

      expect(formRender).toHaveBeenCalledTimes(2); // input now has value

      expect(inputRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(inputRender, 1).input.value).toBe('bob'); // check state

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            values: {
              deep: {
                foo: 'bob'
              }
            },
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }); // unmount form

      var toggle = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(toggle); // check state not destroyed


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            values: {
              deep: {
                foo: 'bob'
              }
            },
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 0
              }
            }
          }
        }
      }); // form still not rendered again

      expect(formRender).toHaveBeenCalledTimes(2); // toggle form back into existence

      _testUtils.default.Simulate.click(toggle); // form is back


      expect(formRender).toHaveBeenCalledTimes(3); // input is back, with its old value

      expect(inputRender).toHaveBeenCalledTimes(3);
      expect(propsAtNthRender(inputRender, 2).input.value).toBe('bob');
    });
    it('should keep old form values/initialValues on reinitialize if keepValues is true', function () {
      var store = makeStore({});
      var deepFooInputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var helloInputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues1 = {
        deep: {
          foo: 'bar'
        }
      };
      var initialValues2 = {
        hello: 'world'
      };

      var Form =
      /*#__PURE__*/
      function (_Component30) {
        _inheritsLoose(Form, _Component30);

        function Form() {
          return _Component30.apply(this, arguments) || this;
        }

        var _proto30 = Form.prototype;

        _proto30.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: deepFooInputRender,
            type: "text"
          }), _react.default.createElement(Field, {
            name: "hello",
            component: helloInputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        enableReinitialize: true,
        keepValues: true
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component31) {
        _inheritsLoose(Container, _Component31);

        function Container(props) {
          var _this22;

          _this22 = _Component31.call(this, props) || this;
          _this22.state = {
            initialValues: initialValues1
          };
          return _this22;
        }

        var _proto31 = Container.prototype;

        _proto31.render = function render() {
          var _this23 = this;

          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, this.state)), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this23.setState({
                initialValues: initialValues2
              });
            }
          }, "Init"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              },
              hello: {
                name: 'hello',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues1,
            values: initialValues1
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(deepFooInputRender).toHaveBeenCalled();
      expect(deepFooInputRender).toHaveBeenCalledTimes(2);
      expect(helloInputRender).toHaveBeenCalled();
      expect(helloInputRender).toHaveBeenCalledTimes(1); // Reinitialize the form

      var initButton = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(initButton); // check initialized state


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              },
              hello: {
                name: 'hello',
                type: 'Field',
                count: 1
              }
            },
            initial: _extends({}, initialValues1, initialValues2),
            values: {
              deep: {
                foo: 'bar'
              },
              hello: 'world'
            }
          }
        }
      }); // Expect the form not to rerender

      expect(formRender).toHaveBeenCalledTimes(2); // should not rerender 'deep.foo' input since its value did not change.

      expect(deepFooInputRender).toHaveBeenCalledTimes(2); // should rerender 'hello' input with new value and new meta.initial

      expect(helloInputRender).toHaveBeenCalledTimes(2);
    });
    it('should not keep old form values/initialValues on reinitialize if keepValues is unset/false', function () {
      var store = makeStore({});
      var deepFooInputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var helloInputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var initialValues1 = {
        deep: {
          foo: 'bar'
        }
      };
      var initialValues2 = {
        hello: 'world'
      };

      var Form =
      /*#__PURE__*/
      function (_Component32) {
        _inheritsLoose(Form, _Component32);

        function Form() {
          return _Component32.apply(this, arguments) || this;
        }

        var _proto32 = Form.prototype;

        _proto32.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: deepFooInputRender,
            type: "text"
          }), _react.default.createElement(Field, {
            name: "hello",
            component: helloInputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        enableReinitialize: true,
        keepValues: false
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component33) {
        _inheritsLoose(Container, _Component33);

        function Container(props) {
          var _this24;

          _this24 = _Component33.call(this, props) || this;
          _this24.state = {
            initialValues: initialValues1
          };
          return _this24;
        }

        var _proto33 = Container.prototype;

        _proto33.render = function render() {
          var _this25 = this;

          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, this.state)), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this25.setState({
                initialValues: initialValues2
              });
            }
          }, "Init"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              },
              hello: {
                name: 'hello',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues1,
            values: initialValues1
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(deepFooInputRender).toHaveBeenCalled();
      expect(deepFooInputRender).toHaveBeenCalledTimes(2);
      expect(helloInputRender).toHaveBeenCalled();
      expect(helloInputRender).toHaveBeenCalledTimes(1); // Reinitialize the form

      var initButton = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(initButton); // check initialized state


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              },
              hello: {
                name: 'hello',
                type: 'Field',
                count: 1
              }
            },
            initial: initialValues2,
            values: {
              hello: 'world'
            }
          }
        }
      }); // Expect the form not to rerender

      expect(formRender).toHaveBeenCalledTimes(2); // should rerender 'deep.foo' input with new value and new meta.initial

      expect(deepFooInputRender).toHaveBeenCalledTimes(3); // should rerender 'hello' input with new value and new meta.initial

      expect(helloInputRender).toHaveBeenCalledTimes(2);
    });
    it('should keep a list of registered fields', function () {
      var store = makeStore({});

      var noopRender = function noopRender() {
        return _react.default.createElement("div", null);
      };

      var Form =
      /*#__PURE__*/
      function (_Component34) {
        _inheritsLoose(Form, _Component34);

        function Form() {
          var _this26;

          _this26 = _Component34.call(this) || this;
          _this26.state = {
            showBar: false
          };
          return _this26;
        }

        var _proto34 = Form.prototype;

        _proto34.render = function render() {
          var _this27 = this;

          var showBar = this.state.showBar;
          return _react.default.createElement("form", null, !showBar && _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }), !showBar && _react.default.createElement(FieldArray, {
            name: "fooArray",
            component: noopRender,
            type: "text"
          }), showBar && _react.default.createElement(Field, {
            name: "bar",
            component: "input",
            type: "text"
          }), showBar && _react.default.createElement(FieldArray, {
            name: "barArray",
            component: noopRender,
            type: "text"
          }), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this27.setState({
                showBar: true
              });
            }
          }, "Show Bar"));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var ref = _react.default.createRef();

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(ref.current.fieldList).toContainExactly(['foo', 'fooArray']); // switch fields

      var button = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(button);

      expect(ref.current.fieldList).toContainExactly(['bar', 'barArray']);
    });
    it('should keep a list of registered fields inside a FormSection', function () {
      var store = makeStore({});

      var noopRender = function noopRender() {
        return _react.default.createElement("div", null);
      };

      var Form =
      /*#__PURE__*/
      function (_Component35) {
        _inheritsLoose(Form, _Component35);

        function Form() {
          var _this28;

          _this28 = _Component35.call(this) || this;
          _this28.state = {
            showBar: false
          };
          return _this28;
        }

        var _proto35 = Form.prototype;

        _proto35.render = function render() {
          var _this29 = this;

          var showBar = this.state.showBar;
          return _react.default.createElement("form", null, _react.default.createElement(_FormSection.default, {
            name: "sec"
          }, !showBar && _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }), !showBar && _react.default.createElement(FieldArray, {
            name: "fooArray",
            component: noopRender,
            type: "text"
          }), showBar && _react.default.createElement(Field, {
            name: "bar",
            component: "input",
            type: "text"
          }), showBar && _react.default.createElement(FieldArray, {
            name: "barArray",
            component: noopRender,
            type: "text"
          }), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this29.setState({
                showBar: true
              });
            }
          }, "Show Bar")));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var ref = _react.default.createRef();

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(ref.current.fieldList).toContainExactly(['sec.foo', 'sec.fooArray']); // switch fields

      var button = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(button);

      expect(ref.current.fieldList).toContainExactly(['sec.bar', 'sec.barArray']);
    });
    it('should not set FieldArray as touched on submit', function () {
      var store = makeStore({});
      var onSubmit = jest.fn();

      var noopRender = function noopRender() {
        return _react.default.createElement("div", null);
      };

      var Form =
      /*#__PURE__*/
      function (_Component36) {
        _inheritsLoose(Form, _Component36);

        function Form() {
          return _Component36.apply(this, arguments) || this;
        }

        var _proto36 = Form.prototype;

        _proto36.render = function render() {
          var handleSubmit = this.props.handleSubmit;
          return _react.default.createElement("form", {
            onSubmit: handleSubmit
          }, _react.default.createElement(FieldArray, {
            name: "fooArray",
            component: noopRender,
            type: "text"
          }), _react.default.createElement("button", {
            type: "submit"
          }, "Submit"));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        onSubmit: onSubmit
      })));

      var form = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'form');

      _testUtils.default.Simulate.submit(form);

      expect(onSubmit).toHaveBeenCalled();
      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            anyTouched: true,
            registeredFields: {
              fooArray: {
                name: 'fooArray',
                type: 'FieldArray',
                count: 1
              }
            },
            submitSucceeded: true
          }
        }
      });
    });
    it('should provide valid/invalid/values/dirty/pristine getters', function () {
      var store = makeStore({});
      var input = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "bar",
          component: input,
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        validate: function validate(values) {
          return getIn(values, 'bar') ? {} : {
            bar: 'Required'
          };
        }
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      }))); // invalid because no value for 'bar' field


      expect(ref.current.dirty).toBe(false);
      expect(ref.current.pristine).toBe(true);
      expect(ref.current.valid).toBe(false);
      expect(ref.current.invalid).toBe(true);
      expect(ref.current.values).toEqualMap({}); // set value for 'bar' field

      input.mock.calls[0][0].input.onChange('foo'); // valid because we have a value for 'bar' field

      expect(ref.current.dirty).toBe(true);
      expect(ref.current.pristine).toBe(false);
      expect(ref.current.valid).toBe(true);
      expect(ref.current.invalid).toBe(false);
      expect(ref.current.values).toEqualMap({
        bar: 'foo'
      });
    });
    it('should mark all fields as touched on submit', function () {
      var store = makeStore({
        testForm: {}
      });
      var username = jest.fn(function (props) {
        return _react.default.createElement("input", _extends({}, props.input, {
          type: "text"
        }));
      });
      var password = jest.fn(function (props) {
        return _react.default.createElement("input", _extends({}, props.input, {
          type: "password"
        }));
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "username",
          component: username,
          type: "text"
        }), _react.default.createElement(Field, {
          name: "password",
          component: password,
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: function onSubmit() {
          return {
            _error: 'Login Failed'
          };
        }
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              username: {
                name: 'username',
                type: 'Field',
                count: 1
              },
              password: {
                name: 'password',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      });
      expect(username).toHaveBeenCalled();
      expect(propsAtNthRender(username, 0).meta.touched).toBe(false);
      expect(password).toHaveBeenCalled();
      expect(propsAtNthRender(password, 0).meta.touched).toBe(false);
      expect(typeof ref.current.submit).toBe('function');
      ref.current.submit();
      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              username: {
                name: 'username',
                type: 'Field',
                count: 1
              },
              password: {
                name: 'password',
                type: 'Field',
                count: 1
              }
            },
            anyTouched: true,
            fields: {
              username: {
                touched: true
              },
              password: {
                touched: true
              }
            },
            submitSucceeded: true
          }
        }
      });
      expect(username).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(username, 1).meta.touched).toBe(true);
      expect(password).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(password, 1).meta.touched).toBe(true);
    });
    it('should call onSubmitFail with errors if sync submit fails by throwing SubmissionError', function () {
      var store = makeStore({
        testForm: {}
      });
      var errors = {
        username: 'Required'
      };
      var onSubmitFail = jest.fn();

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "username",
          component: "input",
          type: "text"
        }), _react.default.createElement(Field, {
          name: "password",
          component: "input",
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: function onSubmit() {
          throw new _SubmissionError.default(errors);
        },
        onSubmitFail: onSubmitFail
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(typeof ref.current.submit).toBe('function');
      expect(onSubmitFail).not.toHaveBeenCalled();
      var caught = ref.current.submit();
      expect(onSubmitFail).toHaveBeenCalled();
      expect(onSubmitFail.mock.calls[0][0]).toEqual(errors);
      expect(onSubmitFail.mock.calls[0][1]).toEqual(store.dispatch);
      expect(onSubmitFail.mock.calls[0][2]).toBeInstanceOf(_SubmissionError.default);
      expect(caught).toBe(errors);
    });
    it('should call onSubmitFail with undefined if sync submit fails by throwing other error', function () {
      var store = makeStore({
        testForm: {}
      });
      var onSubmitFail = jest.fn();

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "username",
          component: "input",
          type: "text"
        }), _react.default.createElement(Field, {
          name: "password",
          component: "input",
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: function onSubmit() {
          throw new Error('Some other error');
        },
        onSubmitFail: onSubmitFail
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(typeof ref.current.submit).toBe('function');
      expect(onSubmitFail).not.toHaveBeenCalled();
      var caught = ref.current.submit();
      expect(onSubmitFail).toHaveBeenCalled();
      expect(onSubmitFail.mock.calls[0][0]).toEqual(undefined);
      expect(onSubmitFail.mock.calls[0][1]).toEqual(store.dispatch);
      expect(onSubmitFail.mock.calls[0][2]).toBeInstanceOf(Error);
      expect(caught).toBeFalsy();
    });
    it('should call onSubmitFail if async submit fails', function () {
      var store = makeStore({
        testForm: {}
      });
      var errors = {
        username: 'Required'
      };
      var onSubmitFail = jest.fn();

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "username",
          component: "input",
          type: "text"
        }), _react.default.createElement(Field, {
          name: "password",
          component: "input",
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: function onSubmit() {
          return Promise.reject(new _SubmissionError.default(errors));
        },
        onSubmitFail: onSubmitFail
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(typeof ref.current.submit).toBe('function');
      expect(onSubmitFail).not.toHaveBeenCalled();
      return ref.current.submit().then(function (caught) {
        expect(onSubmitFail).toHaveBeenCalled();
        expect(onSubmitFail.mock.calls[0][0]).toEqual(errors);
        expect(onSubmitFail.mock.calls[0][1]).toEqual(store.dispatch);
        expect(onSubmitFail.mock.calls[0][2]).toBeInstanceOf(_SubmissionError.default);
        expect(caught).toBe(errors);
      });
    });
    it('should call onSubmitFail if sync validation prevents submit', function () {
      var store = makeStore({
        testForm: {}
      });
      var errors = {
        username: 'Required'
      };
      var onSubmit = jest.fn();
      var onSubmitFail = jest.fn();

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "username",
          component: "input",
          type: "text"
        }), _react.default.createElement(Field, {
          name: "password",
          component: "input",
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: onSubmit,
        onSubmitFail: onSubmitFail,
        validate: function validate() {
          return errors;
        }
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(typeof ref.current.submit).toBe('function');
      expect(onSubmitFail).not.toHaveBeenCalled();
      expect(onSubmit).not.toHaveBeenCalled();
      var result = ref.current.submit();
      expect(onSubmit).not.toHaveBeenCalled();
      expect(onSubmitFail).toHaveBeenCalled();
      expect(onSubmitFail.mock.calls[0][0]).toEqual(errors);
      expect(onSubmitFail.mock.calls[0][1]).toEqual(store.dispatch);
      expect(onSubmitFail.mock.calls[0][2]).toBe(null);
      expect(result).toEqual(errors);
    });

    var UsernamePasswordForm = function UsernamePasswordForm() {
      return _react.default.createElement("form", null, _react.default.createElement(Field, {
        name: "username",
        component: "input",
        type: "text"
      }), _react.default.createElement(Field, {
        name: "password",
        component: "input",
        type: "text"
      }));
    };

    var expectReadyForFirstSubmission = function expectReadyForFirstSubmission(submit, onSubmit, onSubmitFail) {
      expect(typeof submit).toBe('function');
      expect(onSubmit).not.toHaveBeenCalled();
      expect(onSubmitFail).not.toHaveBeenCalled();
    };

    var expectSubmitFailedWithErrors = function expectSubmitFailedWithErrors(onSubmit, onSubmitFail, dispatch, errors) {
      return function (error) {
        expect(onSubmit).not.toHaveBeenCalled();
        expect(onSubmitFail).toHaveBeenCalled();
        expect(onSubmitFail.mock.calls[0][0]).toEqual(errors);
        expect(onSubmitFail.mock.calls[0][1]).toEqual(dispatch);
        expect(onSubmitFail.mock.calls[0][2]).toBe(null);
        expect(error).toBe(errors);
      };
    };

    var ref = _react.default.createRef();

    var wrappedInProvider = function wrappedInProvider(TheComponent, store) {
      return _react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(TheComponent, {
        ref: ref
      }));
    };

    var rejectPromiseWith = function rejectPromiseWith(errors) {
      return function () {
        return Promise.reject(errors);
      };
    };

    var renderAndFindComponent = function renderAndFindComponent(TheComponent, store) {
      _testUtils.default.renderIntoDocument(wrappedInProvider(TheComponent, store));

      return ref.current;
    };

    var itShouldCallOnSubmitFailIfAsyncValidationPreventsSubmit = function itShouldCallOnSubmitFailIfAsyncValidationPreventsSubmit(formProps) {
      var store = makeStore({
        testForm: {}
      });
      var errors = {
        username: 'Required'
      };
      var onSubmit = jest.fn();
      var onSubmitFail = jest.fn();
      var Decorated = reduxForm(_extends({
        form: 'testForm',
        asyncValidate: rejectPromiseWith(errors),
        onSubmit: onSubmit,
        onSubmitFail: onSubmitFail
      }, formProps))(UsernamePasswordForm);
      var stub = renderAndFindComponent(Decorated, store);
      expectReadyForFirstSubmission(stub.submit, onSubmit, onSubmitFail);
      return stub.submit().catch(expectSubmitFailedWithErrors(onSubmit, onSubmitFail, store.dispatch, errors));
    };

    it('should call onSubmitFail if async validation prevents submit', function () {
      return itShouldCallOnSubmitFailIfAsyncValidationPreventsSubmit();
    });
    it('should call onSubmitFail if async validation prevents submit with asyncChangeFields specified', function () {
      return itShouldCallOnSubmitFailIfAsyncValidationPreventsSubmit({
        asyncChangeFields: ['username']
      });
    });
    it('should call onSubmitFail if async validation prevents submit with asyncBlurFields specified', function () {
      return itShouldCallOnSubmitFailIfAsyncValidationPreventsSubmit({
        asyncBlurFields: ['username']
      });
    });
    it('should call onSubmitSuccess if sync submit succeeds', function () {
      var store = makeStore({
        testForm: {}
      });
      var result = {
        message: 'Good job!'
      };
      var onSubmitSuccess = jest.fn();

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "username",
          component: "input",
          type: "text"
        }), _react.default.createElement(Field, {
          name: "password",
          component: "input",
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: function onSubmit() {
          return result;
        },
        onSubmitSuccess: onSubmitSuccess
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(typeof ref.current.submit).toBe('function');
      expect(onSubmitSuccess).not.toHaveBeenCalled();
      var returned = ref.current.submit();
      expect(onSubmitSuccess).toHaveBeenCalled();
      expect(onSubmitSuccess.mock.calls[0][0]).toBe(result);
      expect(onSubmitSuccess.mock.calls[0][1]).toBe(store.dispatch);
      expect(typeof onSubmitSuccess.mock.calls[0][2]).toBe('object');
      expect(returned).toBe(result);
    });
    it('should call onSubmitSuccess if async submit succeeds', function () {
      var store = makeStore({
        testForm: {}
      });
      var result = {
        message: 'Good job!'
      };
      var onSubmitSuccess = jest.fn();

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "username",
          component: "input",
          type: "text"
        }), _react.default.createElement(Field, {
          name: "password",
          component: "input",
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: function onSubmit() {
          return Promise.resolve(result);
        },
        onSubmitSuccess: onSubmitSuccess
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(typeof ref.current.submit).toBe('function');
      expect(onSubmitSuccess).not.toHaveBeenCalled();
      return ref.current.submit().then(function (returned) {
        expect(onSubmitSuccess).toHaveBeenCalled();
        expect(onSubmitSuccess.mock.calls[0][0]).toBe(result);
        expect(onSubmitSuccess.mock.calls[0][1]).toBe(store.dispatch);
        expect(typeof onSubmitSuccess.mock.calls[0][2]).toBe('object');
        expect(returned).toBe(result);
      });
    });
    it('should return error thrown by sync onSubmit', function () {
      var store = makeStore({
        testForm: {}
      });
      var errors = {
        username: 'Required'
      };

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "username",
          component: "input",
          type: "text"
        }), _react.default.createElement(Field, {
          name: "password",
          component: "input",
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: function onSubmit() {
          throw new _SubmissionError.default(errors);
        }
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(typeof ref.current.submit).toBe('function');
      var caught = ref.current.submit();
      expect(caught).toBe(errors);
    });
    it('should submit when submit() called and onSubmit provided as config param', function () {
      var store = makeStore({
        testForm: {
          values: {
            bar: 'foo'
          }
        }
      });
      var input = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "bar",
          component: input,
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: function onSubmit(values) {
          expect(values).toEqualMap({
            bar: 'foo'
          });
        }
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(input).toHaveBeenCalled();
      expect(propsAtNthRender(input, 0).input.value).toBe('foo');
      expect(typeof ref.current.submit).toBe('function');
      ref.current.submit();
    });
    it('should submit when "submit" button is clicked and handleSubmit provided function', function () {
      var store = makeStore({
        testForm: {
          values: {
            bar: 'foo'
          }
        }
      });
      var submit = jest.fn();

      var Form = function Form(_ref) {
        var handleSubmit = _ref.handleSubmit;
        return _react.default.createElement("form", {
          onSubmit: handleSubmit(submit)
        }, _react.default.createElement(Field, {
          name: "bar",
          component: "textarea"
        }), _react.default.createElement("input", {
          type: "submit",
          value: "Submit"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      var form = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'form');

      expect(submit).not.toHaveBeenCalled();

      _testUtils.default.Simulate.submit(form);

      expect(submit).toHaveBeenCalled();
    });
    it('should submit when using Form Wrapper and "submit" button is clicked with onSubmit provided as config param', function () {
      var store = makeStore({
        testForm: {
          values: {
            bar: 'foo'
          }
        }
      });

      var Form = function Form(_ref2) {
        var handleSubmit = _ref2.handleSubmit;
        return _react.default.createElement(_Form.default, {
          onSubmit: handleSubmit
        }, _react.default.createElement(Field, {
          name: "bar",
          component: "textarea"
        }), _react.default.createElement("input", {
          type: "submit",
          value: "Submit"
        }));
      };

      var submit = jest.fn();
      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: submit
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      var form = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'form');

      expect(submit).not.toHaveBeenCalled();

      _testUtils.default.Simulate.submit(form);

      expect(submit).toHaveBeenCalled(); // avoid recursive stack trace

      expect(submit.mock.calls.length).toEqual(1);
    });
    it('should no resubmit if async submit is in progress', function () {
      var store = makeStore({
        testForm: {}
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "username",
          component: "input",
          type: "text"
        }), _react.default.createElement(Field, {
          name: "password",
          component: "input",
          type: "text"
        }));
      };

      var submitSpy = jest.fn().mockImplementation(function () {
        return new Promise(function () {
          /* Promise will never resolve */
        });
      });
      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: submitSpy
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      ref.current.submit();
      ref.current.submit();
      expect(submitSpy.mock.calls.length).toEqual(1);
    });
    it('should delete submit promise when dispatching stopSubmit', function () {
      var store = makeStore({
        testForm: {}
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "username",
          component: "input",
          type: "text"
        }), _react.default.createElement(Field, {
          name: "password",
          component: "input",
          type: "text"
        }));
      };

      var submitSpy = jest.fn().mockImplementation(function () {
        return new Promise(function () {
          /* Promise will never resolve */
        });
      });
      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: submitSpy
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      ref.current.submit();
      store.dispatch(stopSubmit('testForm', {}));
      ref.current.submit();
      expect(submitSpy.mock.calls.length).toEqual(2);
    });
    it('should be fine if form is not yet in Redux store', function () {
      var store = makeStore({
        anotherForm: {
          values: {
            bar: 'foo'
          }
        }
      });
      var input = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "foo",
          component: input,
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(input).toHaveBeenCalled();
      expect(propsAtNthRender(input, 0).input.value).toBe('');
    });
    it('should be fine if getFormState returns nothing', function () {
      var store = makeStore({});
      var input = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "foo",
          component: input,
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        getFormState: function getFormState() {
          return undefined;
        }
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(input).toHaveBeenCalled();
      expect(propsAtNthRender(input, 0).input.value).toBe('');
    });
    it('should throw an error when no onSubmit is specified', function () {
      var store = makeStore({
        testForm: {
          values: {
            bar: 'foo'
          }
        }
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "bar",
          component: "input",
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(function () {
        return ref.current.submit();
      }).toThrow(/onSubmit function or pass onSubmit as a prop/);
    });
    it('should submit (with async validation) when submit() called', function () {
      var store = makeStore({
        testForm: {
          values: {
            bar: 'foo'
          }
        }
      });
      var input = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var asyncValidate = jest.fn(function () {
        return Promise.resolve();
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "bar",
          component: input,
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        asyncValidate: asyncValidate,
        onSubmit: function onSubmit(values) {
          expect(values).toEqualMap({
            bar: 'foo'
          });
        }
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(input).toHaveBeenCalled();
      expect(propsAtNthRender(input, 0).input.value).toBe('foo');
      expect(asyncValidate).not.toHaveBeenCalled();
      expect(typeof ref.current.submit).toBe('function');
      ref.current.submit();
      expect(asyncValidate).toHaveBeenCalled();
      expect(propsAtNthRender(asyncValidate, 0)).toEqualMap({
        bar: 'foo'
      });
    });
    it('should not call async validation more than once if submit is clicked fast when handleSubmit receives an event', function () {
      var store = makeStore({
        testForm: {
          values: {
            bar: 'foo'
          }
        }
      });
      var input = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var asyncValidate = jest.fn(function () {
        return new Promise(function (resolve) {
          return setTimeout(resolve, 100);
        });
      });

      var onSubmit = function onSubmit(values) {
        expect(values).toEqualMap({
          bar: 'foo'
        });
      };

      var Form = function Form(_ref3) {
        var handleSubmit = _ref3.handleSubmit;
        return _react.default.createElement("form", {
          onSubmit: handleSubmit
        }, _react.default.createElement(Field, {
          name: "bar",
          component: input,
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        asyncValidate: asyncValidate,
        onSubmit: onSubmit
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      var form = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'form');

      expect(input).toHaveBeenCalled();
      expect(propsAtNthRender(input, 0).input.value).toBe('foo');
      expect(asyncValidate).not.toHaveBeenCalled();

      _testUtils.default.Simulate.submit(form);

      _testUtils.default.Simulate.submit(form);

      _testUtils.default.Simulate.submit(form);

      _testUtils.default.Simulate.submit(form);

      _testUtils.default.Simulate.submit(form);

      expect(asyncValidate).toHaveBeenCalled();
      expect(asyncValidate).toHaveBeenCalledTimes(1);
      expect(propsAtNthRender(asyncValidate, 0)).toEqualMap({
        bar: 'foo'
      });
    });
    it('should return rejected promise when submit is rejected', function () {
      var store = makeStore({
        testForm: {
          values: {
            bar: 'foo'
          }
        }
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "bar",
          component: "input",
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: function onSubmit() {
          return Promise.reject(new _SubmissionError.default('Rejection'));
        }
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      return ref.current.submit().then(function (err) {
        expect(err).toBe('Rejection');
      });
    });
    it('should not call async validation more than once if submit is clicked fast when handleSubmit receives a function', function () {
      var store = makeStore({
        testForm: {
          values: {
            bar: 'foo'
          }
        }
      });
      var input = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var asyncValidate = jest.fn(function () {
        return new Promise(function (resolve) {
          return setTimeout(resolve, 100);
        });
      });

      var onSubmit = function onSubmit(values) {
        expect(values).toEqualMap({
          bar: 'foo'
        });
      };

      var Form = function Form(_ref4) {
        var handleSubmit = _ref4.handleSubmit;
        return _react.default.createElement("form", {
          onSubmit: handleSubmit(onSubmit)
        }, _react.default.createElement(Field, {
          name: "bar",
          component: input,
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        asyncValidate: asyncValidate
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      var form = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'form');

      expect(input).toHaveBeenCalled();
      expect(propsAtNthRender(input, 0).input.value).toBe('foo');
      expect(asyncValidate).not.toHaveBeenCalled();

      _testUtils.default.Simulate.submit(form);

      _testUtils.default.Simulate.submit(form);

      _testUtils.default.Simulate.submit(form);

      _testUtils.default.Simulate.submit(form);

      _testUtils.default.Simulate.submit(form);

      expect(asyncValidate).toHaveBeenCalled();
      expect(asyncValidate).toHaveBeenCalledTimes(1);
      expect(propsAtNthRender(asyncValidate, 0)).toEqualMap({
        bar: 'foo'
      });
    });
    it('should reset when reset() called', function () {
      var store = makeStore({});
      var input = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "bar",
          component: input,
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        initialValues: {
          bar: 'initialBar'
        }
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(input).toHaveBeenCalled();
      expect(input).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(input, 1).input.value).toBe('initialBar');
      input.mock.calls[1][0].input.onChange('newBar');
      expect(input).toHaveBeenCalledTimes(3);
      expect(propsAtNthRender(input, 2).input.value).toBe('newBar');
      expect(typeof ref.current.reset).toBe('function');
      ref.current.reset();
      expect(input).toHaveBeenCalledTimes(4);
      expect(propsAtNthRender(input, 3).input.value).toBe('initialBar');
    });
    it('should rerender form, but not fields, when non-redux-form props change', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component37) {
        _inheritsLoose(Form, _Component37);

        function Form() {
          return _Component37.apply(this, arguments) || this;
        }

        var _proto37 = Form.prototype;

        _proto37.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component38) {
        _inheritsLoose(Container, _Component38);

        function Container(props) {
          var _this30;

          _this30 = _Component38.call(this, props) || this;
          _this30.state = {};
          return _this30;
        }

        var _proto38 = Container.prototype;

        _proto38.render = function render() {
          var _this31 = this;

          return _react.default.createElement("div", null, _react.default.createElement(_reactRedux.Provider, {
            store: store
          }, _react.default.createElement(Decorated, this.state)), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this31.setState({
                someOtherProp: 42
              });
            }
          }, "Init"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(Container, null));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(propsAtNthRender(formRender, 0).someOtherProp).toBeFalsy();
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(1); // initialize

      var initButton = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(initButton); // rerender form on prop change


      expect(formRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(formRender, 1).someOtherProp).toBe(42); // no need to rerender input

      expect(inputRender).toHaveBeenCalledTimes(1);
    });
    it('should provide error prop from sync validation', function () {
      var store = makeStore({});
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component39) {
        _inheritsLoose(Form, _Component39);

        function Form() {
          return _Component39.apply(this, arguments) || this;
        }

        var _proto39 = Form.prototype;

        _proto39.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        validate: function validate() {
          return {
            _error: 'form wide sync error'
          };
        }
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(formRender, 1).error).toBe('form wide sync error');
    });
    it('values passed to sync validation function should be defined', function () {
      var store = makeStore({});
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component40) {
        _inheritsLoose(Form, _Component40);

        function Form() {
          return _Component40.apply(this, arguments) || this;
        }

        var _proto40 = Form.prototype;

        _proto40.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        enableReinitialize: true,
        initialValues: {
          foo: 'bar'
        },
        validate: function validate(values) {
          expect(values).toBeTruthy();
          return {};
        }
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
    });
    it('should re-run sync validation when props change iff shouldValidate is overridden', function () {
      var store = makeStore({});
      var formRender = jest.fn();
      var renderInput = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var validate = jest.fn(function (values, props) {
        var errors = {};

        if (getIn(values, 'amount') > props.max) {
          errors.amount = "Should be <= " + props.max;
        }

        return errors;
      });

      var shouldValidate = function shouldValidate(_ref5) {
        var values = _ref5.values,
            nextProps = _ref5.nextProps,
            props = _ref5.props,
            initialRender = _ref5.initialRender,
            structure = _ref5.structure;

        if (initialRender) {
          return true;
        }

        return initialRender || !structure.deepEqual(values, nextProps.values) || props.max !== nextProps.max; // must specifically check prop we know might change
      };

      var Form =
      /*#__PURE__*/
      function (_Component41) {
        _inheritsLoose(Form, _Component41);

        function Form() {
          return _Component41.apply(this, arguments) || this;
        }

        var _proto41 = Form.prototype;

        _proto41.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "amount",
            component: renderInput,
            type: "number"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        initialValues: {
          amount: 3
        },
        shouldValidate: shouldValidate,
        validate: validate
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component42) {
        _inheritsLoose(Container, _Component42);

        function Container() {
          var _this32;

          _this32 = _Component42.call(this) || this;
          _this32.state = {
            max: 5
          };
          return _this32;
        }

        var _proto42 = Container.prototype;

        _proto42.render = function render() {
          var _this33 = this;

          return _react.default.createElement("div", null, _react.default.createElement(Decorated, this.state), "}", _react.default.createElement("button", {
            onClick: function onClick() {
              return _this33.setState({
                max: _this33.state.max + 1
              });
            }
          }, "Increment"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Container, null)));

      var validateLastCalledWith = function validateLastCalledWith(amount, max) {
        expect(getIn(validate.mock.calls[validate.mock.calls.length - 1][0], 'amount')).toBe(amount);
        expect(validate.mock.calls[validate.mock.calls.length - 1][1].max).toBe(max);
      };

      expect(formRender).toHaveBeenCalled(); // form is valid (3 < 5)

      validateLastCalledWith(3, 5);
      expect(propsAtLastRender(formRender).valid).toBe(true); // change amount to 6

      propsAtNthRender(renderInput, 0).input.onChange(6); // form is invalid (6 !<= 5)

      validateLastCalledWith(6, 5);
      expect(propsAtLastRender(formRender).valid).toBe(false); // increment max to 6

      var increment = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(increment); // form is valid (6 <= 6)


      validateLastCalledWith(6, 6);
      expect(propsAtLastRender(formRender).valid).toBe(true);
    });
    it('should properly remove error prop from sync validation', function () {
      var store = makeStore({});
      var input = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component43) {
        _inheritsLoose(Form, _Component43);

        function Form() {
          return _Component43.apply(this, arguments) || this;
        }

        var _proto43 = Form.prototype;

        _proto43.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: input,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        validate: function validate(values) {
          return getIn(values, 'foo') ? {} : {
            _error: 'form wide sync error'
          };
        }
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(formRender, 1).error).toBe('form wide sync error');
      expect(propsAtNthRender(formRender, 1).valid).toBe(false);
      expect(propsAtNthRender(formRender, 1).invalid).toBe(true);
      input.mock.calls[0][0].input.onChange('bar');
      expect(formRender).toHaveBeenCalledTimes(4);
      expect(propsAtNthRender(formRender, 3).error).toBeFalsy();
      expect(propsAtNthRender(formRender, 3).valid).toBe(true);
      expect(propsAtNthRender(formRender, 3).invalid).toBe(false);
    });
    it('should allow for sync errors to be objects', function () {
      var store = makeStore({});
      var formRender = jest.fn();
      var renderInput = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var error = {
        complex: 'object',
        manyKeys: true
      };

      var Form =
      /*#__PURE__*/
      function (_Component44) {
        _inheritsLoose(Form, _Component44);

        function Form() {
          return _Component44.apply(this, arguments) || this;
        }

        var _proto44 = Form.prototype;

        _proto44.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: renderInput,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        validate: function validate() {
          return {
            foo: error
          };
        }
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(formRender, 1).valid).toBe(false);
      expect(propsAtNthRender(formRender, 1).invalid).toBe(true);
      expect(renderInput).toHaveBeenCalled();
      expect(renderInput).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(renderInput, 1).meta.error).toEqual(error);
    });
    it('should allow sync validation for array props on push', function () {
      var store = makeStore({});
      var formRender = jest.fn();
      var inputs = [jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      }), jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      }), jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      })];

      var renderArray = function renderArray(_ref6) {
        var fields = _ref6.fields;
        return _react.default.createElement("div", null, fields.map(function (name, index) {
          return _react.default.createElement(Field, {
            name: name,
            key: index,
            component: inputs[index]
          });
        }));
      };

      var validate = function validate(values) {
        var errors = {
          foo: []
        };
        var foo = getIn(values, 'foo');

        if (foo) {
          foo.forEach(function (value, index) {
            if (value < 10) {
              errors.foo[index] = 'Too low';
            }
          });
        }

        return errors;
      };

      var Form =
      /*#__PURE__*/
      function (_Component45) {
        _inheritsLoose(Form, _Component45);

        function Form() {
          return _Component45.apply(this, arguments) || this;
        }

        var _proto45 = Form.prototype;

        _proto45.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(FieldArray, {
            name: "foo",
            component: renderArray
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        validate: validate
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(inputs[0]).not.toHaveBeenCalled();
      expect(inputs[1]).not.toHaveBeenCalled();
      expect(inputs[2]).not.toHaveBeenCalled();
      propsAtNthRender(formRender, 0).array.push('foo', 3); // first input rendered

      expect(inputs[0]).toHaveBeenCalled();
      expect(inputs[0]).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(inputs[0], 1).meta.valid).toBe(false);
      expect(propsAtNthRender(inputs[0], 1).meta.error).toBe('Too low');
      expect(inputs[1]).not.toHaveBeenCalled();
      expect(inputs[2]).not.toHaveBeenCalled(); // add additional value

      propsAtNthRender(formRender, 0).array.push('foo', 13); // first input not rendered again

      expect(inputs[0]).toHaveBeenCalledTimes(2); // but second input now rendered

      expect(inputs[1]).toHaveBeenCalled();
      expect(inputs[1]).toHaveBeenCalledTimes(1);
      expect(propsAtNthRender(inputs[1], 0).meta.valid).toBe(true);
      expect(propsAtNthRender(inputs[1], 0).input.value).toBe(13);
      expect(inputs[2]).not.toHaveBeenCalled(); // fix original error

      propsAtNthRender(inputs[0], 0).input.onChange(10); // first input rendered again

      expect(inputs[0]).toHaveBeenCalledTimes(4);
      expect(propsAtNthRender(inputs[0], 3).meta.valid).toBe(true);
      expect(propsAtNthRender(inputs[0], 3).meta.error).toBe(undefined);
      expect(inputs[1]).toHaveBeenCalled();
      expect(inputs[2]).not.toHaveBeenCalled();
    });
    it('should provide warning prop from sync warning', function () {
      var store = makeStore({});
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component46) {
        _inheritsLoose(Form, _Component46);

        function Form() {
          return _Component46.apply(this, arguments) || this;
        }

        var _proto46 = Form.prototype;

        _proto46.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        warn: function warn() {
          return {
            _warning: 'form wide sync warning'
          };
        }
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(formRender, 1).warning).toBe('form wide sync warning');
    });
    it('should properly remove warning prop from sync warning', function () {
      var store = makeStore({});
      var input = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component47) {
        _inheritsLoose(Form, _Component47);

        function Form() {
          return _Component47.apply(this, arguments) || this;
        }

        var _proto47 = Form.prototype;

        _proto47.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: input,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        warn: function warn(values) {
          return getIn(values, 'foo') ? {} : {
            _warning: 'form wide sync warning'
          };
        }
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(formRender, 1).warning).toBe('form wide sync warning');
      input.mock.calls[0][0].input.onChange('bar'); // expect(formRender.calls.length).toBe(4) // TODO: this gets called an extra time (4 instead of 3). why?

      expect(propsAtNthRender(formRender, 3).warning).toBeFalsy();
    });
    it('should allow for sync warnings to be objects', function () {
      var store = makeStore({});
      var formRender = jest.fn();
      var renderInput = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var warning = {
        complex: 'object',
        manyKeys: true
      };

      var Form =
      /*#__PURE__*/
      function (_Component48) {
        _inheritsLoose(Form, _Component48);

        function Form() {
          return _Component48.apply(this, arguments) || this;
        }

        var _proto48 = Form.prototype;

        _proto48.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: renderInput,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        warn: function warn() {
          return {
            foo: warning
          };
        }
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled(); // expect(formRender.calls.length).toBe(2) // TODO: This gets called only once. Why?

      expect(renderInput).toHaveBeenCalled();
      expect(renderInput).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(renderInput, 1).meta.warning).toEqual(warning);
    });
    it('should call async on blur of async blur field', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var asyncErrors = {
        deep: {
          foo: 'async error'
        }
      };
      var asyncValidate = jest.fn().mockImplementation(function () {
        return Promise.reject(asyncErrors);
      });

      var Form =
      /*#__PURE__*/
      function (_Component49) {
        _inheritsLoose(Form, _Component49);

        function Form() {
          return _Component49.apply(this, arguments) || this;
        }

        var _proto49 = Form.prototype;

        _proto49.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        asyncValidate: asyncValidate,
        asyncBlurFields: ['deep.foo'],
        asyncChangeFields: []
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(asyncValidate).not.toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(1);
      expect(propsAtNthRender(inputRender, 0).meta.pristine).toBe(true);
      expect(propsAtNthRender(inputRender, 0).input.value).toBe('');
      expect(propsAtNthRender(inputRender, 0).meta.valid).toBe(true);
      expect(propsAtNthRender(inputRender, 0).meta.error).toBe(undefined);

      var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

      _testUtils.default.Simulate.change(inputElement, {
        target: {
          value: 'bar'
        }
      });

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            values: {
              deep: {
                foo: 'bar'
              }
            },
            registeredFields: {
              'deep.foo': {
                name: 'deep.foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      });
      expect(formRender).toHaveBeenCalledTimes(2); // rerendered because pristine -> dirty

      expect(asyncValidate).not.toHaveBeenCalled(); // not yet

      expect(inputRender).toHaveBeenCalledTimes(2); // input rerendered

      expect(propsAtNthRender(inputRender, 1).meta.pristine).toBe(false);
      expect(propsAtNthRender(inputRender, 1).input.value).toBe('bar');
      expect(propsAtNthRender(inputRender, 1).meta.valid).toBe(true);
      expect(propsAtNthRender(inputRender, 1).meta.error).toBe(undefined);

      _testUtils.default.Simulate.blur(inputElement, {
        target: {
          value: 'bar'
        }
      });

      setTimeout(function () {
        expect(store.getState()).toEqualMap({
          form: {
            testForm: {
              anyTouched: true,
              values: {
                deep: {
                  foo: 'bar'
                }
              },
              fields: {
                deep: {
                  foo: {
                    touched: true
                  }
                }
              },
              registeredFields: {
                'deep.foo': {
                  name: 'deep.foo',
                  type: 'Field',
                  count: 1
                }
              },
              asyncErrors: asyncErrors
            }
          }
        }); // rerender form twice because of async validation start and again for valid -> invalid

        expect(formRender).toHaveBeenCalledTimes(4);
        expect(asyncValidate).toHaveBeenCalled();
        expect(propsAtNthRender(asyncValidate, 0)).toEqualMap({
          deep: {
            foo: 'bar'
          }
        }); // input rerendered twice, at start and end of async validation

        expect(inputRender).toHaveBeenCalledTimes(4);
        expect(propsAtNthRender(inputRender, 3).meta.pristine).toBe(false);
        expect(propsAtNthRender(inputRender, 3).input.value).toBe('bar');
        expect(propsAtNthRender(inputRender, 3).meta.valid).toBe(false);
        expect(propsAtNthRender(inputRender, 3).meta.error).toBe('async error');
      });
    });
    it('should call async on change of async change field', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var asyncErrors = {
        deep: {
          foo: 'async error'
        }
      };
      var asyncValidate = jest.fn().mockImplementation(function () {
        return Promise.reject(asyncErrors);
      });

      var Form =
      /*#__PURE__*/
      function (_Component50) {
        _inheritsLoose(Form, _Component50);

        function Form() {
          return _Component50.apply(this, arguments) || this;
        }

        var _proto50 = Form.prototype;

        _proto50.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "deep.foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        asyncValidate: asyncValidate,
        asyncBlurFields: [],
        asyncChangeFields: ['deep.foo']
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

      _testUtils.default.Simulate.change(inputElement, {
        target: {
          value: 'bar'
        }
      });

      setTimeout(function () {
        expect(store.getState()).toEqualMap({
          form: {
            testForm: {
              anyTouched: true,
              values: {
                deep: {
                  foo: 'bar'
                }
              },
              fields: {
                deep: {
                  foo: {
                    touched: true
                  }
                }
              },
              registeredFields: {
                'deep.foo': {
                  name: 'deep.foo',
                  type: 'Field',
                  count: 1
                }
              },
              asyncErrors: asyncErrors
            }
          }
        }); // rerender form twice because of async validation start and again for valid -> invalid

        expect(formRender.calls.length).toBe(4);
        expect(asyncValidate).toHaveBeenCalled();
        expect(propsAtNthRender(asyncValidate, 0)).toEqualMap({
          deep: {
            foo: 'bar'
          }
        }); // input rerendered twice, at start and end of async validation

        expect(inputRender.calls.length).toBe(4);
        expect(propsAtNthRender(inputRender, 3).meta.pristine).toBe(false);
        expect(propsAtNthRender(inputRender, 3).input.value).toBe('bar');
        expect(propsAtNthRender(inputRender, 3).meta.valid).toBe(false);
        expect(propsAtNthRender(inputRender, 3).meta.error).toBe('async error');
      });
    });
    it('should call form-level onChange when values change', function () {
      var store = makeStore({});
      var renderFoo = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var renderBar = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var onChange = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component51) {
        _inheritsLoose(Form, _Component51);

        function Form() {
          return _Component51.apply(this, arguments) || this;
        }

        var _proto51 = Form.prototype;

        _proto51.render = function render() {
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: renderFoo,
            type: "text"
          }), _react.default.createElement(Field, {
            name: "bar",
            component: renderBar,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        onChange: onChange
      })));

      var changeFoo = renderFoo.mock.calls[0][0].input.onChange;
      var changeBar = renderBar.mock.calls[0][0].input.onChange;
      expect(onChange).not.toHaveBeenCalled();
      changeFoo('dog');
      expect(onChange).toHaveBeenCalled();
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange.mock.calls[0][0]).toEqualMap({
        foo: 'dog'
      });
      expect(typeof onChange.mock.calls[0][1]).toBe('function');
      expect(onChange.mock.calls[0][2].values).toEqualMap({
        foo: 'dog'
      });
      expect(onChange.mock.calls[0][3]).toEqualMap({});
      changeBar('cat');
      expect(onChange).toHaveBeenCalledTimes(2);
      expect(onChange.mock.calls[1][0]).toEqualMap({
        foo: 'dog',
        bar: 'cat'
      });
      expect(typeof onChange.mock.calls[1][1]).toBe('function');
      expect(onChange.mock.calls[1][2].values).toEqualMap({
        foo: 'dog',
        bar: 'cat'
      });
      expect(onChange.mock.calls[1][3]).toEqualMap({
        foo: 'dog'
      });
      changeFoo('dog'); // onChange NOT called since value did not change

      expect(onChange).toHaveBeenCalledTimes(2);
      changeFoo('doggy');
      expect(onChange).toHaveBeenCalledTimes(3);
      expect(onChange.mock.calls[2][0]).toEqualMap({
        foo: 'doggy',
        bar: 'cat'
      });
      expect(typeof onChange.mock.calls[2][1]).toBe('function');
      expect(onChange.mock.calls[2][2].values).toEqualMap({
        foo: 'doggy',
        bar: 'cat'
      });
      expect(onChange.mock.calls[2][3]).toEqualMap({
        foo: 'dog',
        bar: 'cat'
      });
    });
    it('should call form-level onChange when values change using ===', function () {
      var store = makeStore({});
      var renderFoo = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var onChange = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component52) {
        _inheritsLoose(Form, _Component52);

        function Form() {
          return _Component52.apply(this, arguments) || this;
        }

        var _proto52 = Form.prototype;

        _proto52.render = function render() {
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: renderFoo,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        onChange: onChange
      })));

      var changeFoo = renderFoo.mock.calls[0][0].input.onChange;
      expect(onChange).not.toHaveBeenCalled();
      changeFoo(1);
      expect(onChange).toHaveBeenCalledTimes(1);
      changeFoo('1.');
      expect(onChange).toHaveBeenCalledTimes(2);
      changeFoo(1.2);
      expect(onChange).toHaveBeenCalledTimes(3);
    });
    it('should update sync errors after reset when using field-level validation', function () {
      var store = makeStore({});
      var renderName = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var renderAge = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var onChange = jest.fn();

      var required = function required(value) {
        return value ? undefined : 'Required';
      };

      var Form =
      /*#__PURE__*/
      function (_Component53) {
        _inheritsLoose(Form, _Component53);

        function Form() {
          return _Component53.apply(this, arguments) || this;
        }

        var _proto53 = Form.prototype;

        _proto53.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "name",
            component: renderName,
            type: "text",
            validate: required
          }), _react.default.createElement(Field, {
            name: "age",
            component: renderAge,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        onChange: onChange
      }))); // verify original state


      expect(store.getState()).toEqualMap(setIn(fromJS({
        form: {
          testForm: {
            registeredFields: {
              name: {
                name: 'name',
                type: 'Field',
                count: 1
              },
              age: {
                name: 'age',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }), 'form.testForm.syncErrors', {
        name: 'Required'
      })); // verify initial props

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(2); // initial and again with sync error

      expect(renderName).toHaveBeenCalled();
      expect(renderName).toHaveBeenCalledTimes(2); // initial and again with sync error

      expect(propsAtNthRender(renderName, 1).meta.error).toBe('Required');
      expect(propsAtNthRender(renderName, 1).input.value).toBe('');
      expect(renderAge).toHaveBeenCalled();
      expect(renderAge).toHaveBeenCalledTimes(1); // initial only

      expect(propsAtNthRender(renderAge, 0).input.value).toBe('');
      expect(propsAtNthRender(renderAge, 0).meta.pristine).toBe(true); // verify original state

      var originalState = setIn(fromJS({
        form: {
          testForm: {
            registeredFields: {
              name: {
                name: 'name',
                type: 'Field',
                count: 1
              },
              age: {
                name: 'age',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }), 'form.testForm.syncErrors', {
        name: 'Required'
      });
      expect(store.getState()).toEqualMap(originalState); // update age

      propsAtNthRender(renderAge, 0).input.onChange('4'); // verify props

      expect(formRender).toHaveBeenCalledTimes(3); // again for dirty flag

      expect(renderName).toHaveBeenCalledTimes(2); // no need to rerender

      expect(renderAge).toHaveBeenCalledTimes(2); // rerendered with new value

      expect(propsAtNthRender(renderAge, 1).input.value).toBe('4');
      expect(propsAtNthRender(renderAge, 1).meta.pristine).toBe(false); // reset form

      propsAtNthRender(formRender, 0).reset(); // verify that we went back to original state

      expect(store.getState()).toEqualMap(originalState);
      expect(formRender).toHaveBeenCalledTimes(5); // rerendered as pristine, and again with sync error

      expect(renderName).toHaveBeenCalledTimes(4);
      expect(propsAtNthRender(renderName, 3).meta.error).toBe('Required');
      expect(propsAtNthRender(renderName, 3).input.value).toBe('');
      expect(renderAge).toHaveBeenCalledTimes(3); // rendered again as empty and pristine

      expect(propsAtNthRender(renderAge, 2).input.value).toBe('');
      expect(propsAtNthRender(renderAge, 2).meta.pristine).toBe(true);
    });
    it('should update sync warnings after reset when using field-level validation', function () {
      var store = makeStore({});
      var renderName = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var renderAge = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var onChange = jest.fn();

      var required = function required(value) {
        return value ? undefined : 'Required';
      };

      var Form =
      /*#__PURE__*/
      function (_Component54) {
        _inheritsLoose(Form, _Component54);

        function Form() {
          return _Component54.apply(this, arguments) || this;
        }

        var _proto54 = Form.prototype;

        _proto54.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "name",
            component: renderName,
            type: "text",
            warn: required
          }), _react.default.createElement(Field, {
            name: "age",
            component: renderAge,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        onChange: onChange
      }))); // verify original state


      expect(store.getState()).toEqualMap(setIn(fromJS({
        form: {
          testForm: {
            registeredFields: {
              name: {
                name: 'name',
                type: 'Field',
                count: 1
              },
              age: {
                name: 'age',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }), 'form.testForm.syncWarnings', {
        name: 'Required'
      })); // verify initial props

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1); // initial

      expect(renderName).toHaveBeenCalled();
      expect(renderName).toHaveBeenCalledTimes(2); // initial and again with sync warning

      expect(propsAtNthRender(renderName, 1).meta.warning).toBe('Required');
      expect(propsAtNthRender(renderName, 1).input.value).toBe('');
      expect(renderAge).toHaveBeenCalled();
      expect(renderAge).toHaveBeenCalledTimes(1); // initial only

      expect(propsAtNthRender(renderAge, 0).input.value).toBe('');
      expect(propsAtNthRender(renderAge, 0).meta.pristine).toBe(true); // verify original state

      var originalState = setIn(fromJS({
        form: {
          testForm: {
            registeredFields: {
              name: {
                name: 'name',
                type: 'Field',
                count: 1
              },
              age: {
                name: 'age',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }), 'form.testForm.syncWarnings', {
        name: 'Required'
      });
      expect(store.getState()).toEqualMap(originalState); // update age

      propsAtNthRender(renderAge, 0).input.onChange('4'); // verify props

      expect(formRender).toHaveBeenCalledTimes(2); // again for dirty flag

      expect(renderName).toHaveBeenCalledTimes(2); // no need to rerender

      expect(renderAge).toHaveBeenCalledTimes(2); // rerendered with new value

      expect(propsAtNthRender(renderAge, 1).input.value).toBe('4');
      expect(propsAtNthRender(renderAge, 1).meta.pristine).toBe(false); // reset form

      propsAtNthRender(formRender, 0).reset(); // verify that we went back to original state

      expect(store.getState()).toEqualMap(originalState);
      expect(formRender).toHaveBeenCalledTimes(3); // rerendered as pristine

      expect(renderName).toHaveBeenCalledTimes(4);
      expect(propsAtNthRender(renderName, 3).meta.warning).toBe('Required');
      expect(propsAtNthRender(renderName, 3).input.value).toBe('');
      expect(renderAge).toHaveBeenCalledTimes(3); // rendered again as empty and pristine

      expect(propsAtNthRender(renderAge, 2).input.value).toBe('');
      expect(propsAtNthRender(renderAge, 2).meta.pristine).toBe(true);
    });
    describe('validateIfNeeded', function () {
      it('should not call validate if shouldValidate returns false', function () {
        var validate = jest.fn().mockImplementation(function () {
          return {};
        });
        var shouldValidate = jest.fn().mockImplementation(function () {
          return false;
        });
        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          validate: validate,
          shouldValidate: shouldValidate
        }); // initial render

        expect(shouldValidate).toHaveBeenCalled();
        expect(shouldValidate.mock.calls[0][0].initialRender).toBe(true);
        expect(validate).not.toHaveBeenCalled();
        shouldValidate.mockClear(); // on change

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        });

        expect(shouldValidate).toHaveBeenCalled();
        expect(shouldValidate.mock.calls[0][0].initialRender).toBe(false);
        expect(validate).not.toHaveBeenCalled();
      });
      it('should not call validate if shouldError returns false', function () {
        var validate = jest.fn().mockImplementation(function () {
          return {};
        });
        var shouldError = jest.fn().mockImplementation(function () {
          return false;
        });
        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          validate: validate,
          shouldError: shouldError
        }); // initial render

        expect(shouldError).toHaveBeenCalled();
        expect(shouldError.mock.calls[0][0].initialRender).toBe(true);
        expect(validate).not.toHaveBeenCalled();
        shouldError.mockClear(); // on change

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        });

        expect(shouldError).toHaveBeenCalled();
        expect(shouldError.mock.calls[0][0].initialRender).toBe(false);
        expect(validate).not.toHaveBeenCalled();
      });
      it('should call validate if shouldValidate returns true', function () {
        var validate = jest.fn().mockImplementation(function () {
          return {};
        });
        var shouldValidate = jest.fn().mockImplementation(function () {
          return true;
        });
        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          validate: validate,
          shouldValidate: shouldValidate
        }); // initial render

        expect(shouldValidate).toHaveBeenCalled();
        expect(shouldValidate.mock.calls[0][0].initialRender).toBe(true);
        expect(validate).toHaveBeenCalled();
        shouldValidate.mockClear(); // on change

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        });

        expect(shouldValidate).toHaveBeenCalled();
        expect(shouldValidate.mock.calls[0][0].initialRender).toBe(false);
        expect(validate).toHaveBeenCalled();
      });
      it('should call validate if shouldError returns true', function () {
        var validate = jest.fn().mockImplementation(function () {
          return {};
        });
        var shouldError = jest.fn().mockImplementation(function () {
          return true;
        });
        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          validate: validate,
          shouldError: shouldError
        }); // initial render

        expect(shouldError).toHaveBeenCalled();
        expect(shouldError.mock.calls[0][0].initialRender).toBe(true);
        expect(validate).toHaveBeenCalled();
        shouldError.mockClear(); // on change

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        });

        expect(shouldError).toHaveBeenCalled();
        expect(shouldError.mock.calls[0][0].initialRender).toBe(false);
        expect(validate).toHaveBeenCalled();
      });
      it('should pass values and props to validate if called', function () {
        var propsSpy = jest.fn();
        var validate = jest.fn().mockImplementation(function () {
          return {};
        });

        var shouldValidate = function shouldValidate(args) {
          propsSpy(args.props);
          return true;
        };

        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          validate: validate,
          shouldValidate: shouldValidate
        });
        validate.mockClear();

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        }); // compare values


        expect(validate.mock.calls[0][0]).toEqualMap({
          foo: 'bar'
        }); // compare props

        var propArray = Object.keys(propsSpy.mock.calls[0][0]);
        expect(Object.keys(validate.mock.calls[0][1])).toEqual(propArray);
      });
      it('should pass values and props to validate if shouldError called', function () {
        var propsSpy = jest.fn();
        var validate = jest.fn().mockImplementation(function () {
          return {};
        });

        var shouldError = function shouldError(args) {
          propsSpy(args.props);
          return true;
        };

        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          validate: validate,
          shouldError: shouldError
        });
        validate.mockClear();

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        }); // compare values


        expect(validate.mock.calls[0][0]).toEqualMap({
          foo: 'bar'
        }); // compare props

        var propArray = Object.keys(propsSpy.mock.calls[0][0]);
        expect(Object.keys(validate.mock.calls[0][1])).toEqual(propArray);
      });
    });
    describe('warnIfNeeded', function () {
      it('should not call warn if shouldValidate returns false', function () {
        var warn = jest.fn().mockImplementation(function () {
          return {};
        });
        var shouldValidate = jest.fn().mockImplementation(function () {
          return false;
        });
        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          warn: warn,
          shouldValidate: shouldValidate
        }); // initial render

        expect(shouldValidate).toHaveBeenCalled();
        expect(shouldValidate.mock.calls[0][0].initialRender).toBe(true);
        expect(warn).not.toHaveBeenCalled();
        shouldValidate.mockClear(); // on change

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        });

        expect(shouldValidate).toHaveBeenCalled();
        expect(shouldValidate.mock.calls[0][0].initialRender).toBe(false);
        expect(warn).not.toHaveBeenCalled();
      });
      it('should not call warn if shouldWarn returns false', function () {
        var warn = jest.fn().mockImplementation(function () {
          return {};
        });
        var shouldWarn = jest.fn().mockImplementation(function () {
          return false;
        });
        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          warn: warn,
          shouldWarn: shouldWarn
        }); // initial render

        expect(shouldWarn).toHaveBeenCalled();
        expect(shouldWarn.mock.calls[0][0].initialRender).toBe(true);
        expect(warn).not.toHaveBeenCalled();
        shouldWarn.mockClear(); // on change

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        });

        expect(shouldWarn).toHaveBeenCalled();
        expect(shouldWarn.mock.calls[0][0].initialRender).toBe(false);
        expect(warn).not.toHaveBeenCalled();
      });
      it('should call warn if shouldValidate returns true', function () {
        var warn = jest.fn().mockImplementation(function () {
          return {};
        });
        var shouldValidate = jest.fn().mockImplementation(function () {
          return true;
        });
        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          warn: warn,
          shouldValidate: shouldValidate
        }); // initial render

        expect(shouldValidate).toHaveBeenCalled();
        expect(shouldValidate.mock.calls[0][0].initialRender).toBe(true);
        expect(warn).toHaveBeenCalled();
        shouldValidate.mockClear(); // on change

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        });

        expect(shouldValidate).toHaveBeenCalled();
        expect(shouldValidate.mock.calls[0][0].initialRender).toBe(false);
        expect(warn).toHaveBeenCalled();
      });
      it('should call warn if shouldWarn returns true', function () {
        var warn = jest.fn().mockImplementation(function () {
          return {};
        });
        var shouldWarn = jest.fn().mockImplementation(function () {
          return true;
        });
        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          warn: warn,
          shouldWarn: shouldWarn
        }); // initial render

        expect(shouldWarn).toHaveBeenCalled();
        expect(shouldWarn.mock.calls[0][0].initialRender).toBe(true);
        expect(warn).toHaveBeenCalled();
        shouldWarn.mockClear(); // on change

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        });

        expect(shouldWarn).toHaveBeenCalled();
        expect(shouldWarn.mock.calls[0][0].initialRender).toBe(false);
        expect(warn).toHaveBeenCalled();
      });
      it('should pass values and props to warn if called', function () {
        var propsSpy = jest.fn();
        var warn = jest.fn().mockImplementation(function () {
          return {};
        });

        var shouldValidate = function shouldValidate(args) {
          propsSpy(args.props);
          return true;
        };

        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          warn: warn,
          shouldValidate: shouldValidate
        });
        warn.mockClear();

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        }); // compare values


        expect(warn.mock.calls[0][0]).toEqualMap({
          foo: 'bar'
        }); // compare props

        var propArray = Object.keys(propsSpy.mock.calls[0][0]);
        expect(Object.keys(warn.mock.calls[0][1])).toEqual(propArray);
      });
      it('should pass values and props to warn if shouldWarn called', function () {
        var propsSpy = jest.fn();
        var warn = jest.fn().mockImplementation(function () {
          return {};
        });

        var shouldWarn = function shouldWarn(args) {
          propsSpy(args.props);
          return true;
        };

        var Form = makeForm();
        var dom = renderForm(Form, {}, {
          warn: warn,
          shouldWarn: shouldWarn
        });
        warn.mockClear();

        var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

        _testUtils.default.Simulate.change(inputElement, {
          target: {
            value: 'bar'
          }
        }); // compare values


        expect(warn.mock.calls[0][0]).toEqualMap({
          foo: 'bar'
        }); // compare props

        var propArray = Object.keys(propsSpy.mock.calls[0][0]);
        expect(Object.keys(warn.mock.calls[0][1])).toEqual(propArray);
      });
    });
    it('should not call async validate if shouldAsyncValidate returns false', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var asyncValidate = jest.fn(function () {
        return Promise.reject({
          foo: 'bad user!'
        });
      });
      var shouldAsyncValidate = jest.fn().mockImplementation(function () {
        return false;
      });

      var Form = function Form() {
        return _react.default.createElement("form", null, _react.default.createElement(Field, {
          name: "foo",
          component: inputRender,
          type: "text"
        }));
      };

      var Decorated = reduxForm({
        form: 'testForm',
        asyncValidate: asyncValidate,
        asyncBlurFields: ['foo'],
        asyncChangeFields: [],
        shouldAsyncValidate: shouldAsyncValidate
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              foo: {
                name: 'foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      });
      expect(asyncValidate).not.toHaveBeenCalled();

      var inputElement = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'input');

      _testUtils.default.Simulate.change(inputElement, {
        target: {
          value: 'bar'
        }
      });

      expect(shouldAsyncValidate).not.toHaveBeenCalled();

      _testUtils.default.Simulate.blur(inputElement, {
        target: {
          value: 'bar'
        }
      });

      expect(shouldAsyncValidate).toHaveBeenCalled();
      expect(asyncValidate).not.toHaveBeenCalled();
    });
    it('should expose wrapped instance', function () {
      var store = makeStore({});

      var Form =
      /*#__PURE__*/
      function (_Component55) {
        _inheritsLoose(Form, _Component55);

        function Form() {
          return _Component55.apply(this, arguments) || this;
        }

        var _proto55 = Form.prototype;

        _proto55.render = function render() {
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var ref = _react.default.createRef();

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      var wrapped = _testUtils.default.findRenderedComponentWithType(dom, Form);

      expect(ref.current.wrappedInstance.props).toEqual(wrapped.props);
    });
    it('should return an empty list if there are no registered fields', function () {
      var store = makeStore({});

      var Form =
      /*#__PURE__*/
      function (_Component56) {
        _inheritsLoose(Form, _Component56);

        function Form() {
          return _Component56.apply(this, arguments) || this;
        }

        var _proto56 = Form.prototype;

        _proto56.render = function render() {
          return _react.default.createElement("form", null);
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(ref.current.ref.current.getFieldList()).toEqual([]);
    });
    it('should set autofilled and unset it on change', function () {
      var store = makeStore({});
      var renderInput = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var renderForm = jest.fn();
      var onSubmit = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component57) {
        _inheritsLoose(Form, _Component57);

        function Form() {
          return _Component57.apply(this, arguments) || this;
        }

        var _proto57 = Form.prototype;

        _proto57.render = function render() {
          renderForm(this.props);
          return _react.default.createElement("form", {
            onSubmit: this.props.handleSubmit
          }, _react.default.createElement(Field, {
            name: "myField",
            component: renderInput
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        onSubmit: onSubmit
      })));

      expect(renderForm).toHaveBeenCalled();
      expect(renderForm).toHaveBeenCalledTimes(1);
      expect(typeof renderForm.mock.calls[0][0].autofill).toBe('function'); // check field

      expect(renderInput).toHaveBeenCalled();
      expect(renderInput).toHaveBeenCalledTimes(1);
      expect(renderInput.mock.calls[0][0].input.value).toBe('');
      expect(renderInput.mock.calls[0][0].meta.autofilled).toBe(false);

      var form = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'form'); // test submit


      expect(onSubmit).not.toHaveBeenCalled();

      _testUtils.default.Simulate.submit(form);

      expect(onSubmit).toHaveBeenCalled();
      expect(onSubmit).toHaveBeenCalledTimes(1);
      expect(onSubmit.mock.calls[0][0]).toEqualMap({});
      expect(typeof onSubmit.mock.calls[0][1]).toBe('function');
      expect(onSubmit.mock.calls[0][2].values).toEqualMap({});
      expect(renderInput).toHaveBeenCalledTimes(2); // touched by submit
      // autofill field

      renderForm.mock.calls[0][0].autofill('myField', 'autofilled value'); // check field

      expect(renderInput).toHaveBeenCalled();
      expect(renderInput).toHaveBeenCalledTimes(3);
      expect(renderInput.mock.calls[2][0].input.value).toBe('autofilled value');
      expect(renderInput.mock.calls[2][0].meta.autofilled).toBe(true); // test submitting autofilled value

      _testUtils.default.Simulate.submit(form);

      expect(onSubmit).toHaveBeenCalledTimes(2);
      expect(onSubmit.mock.calls[1][0]).toEqualMap({
        myField: 'autofilled value'
      });
      expect(typeof onSubmit.mock.calls[1][1]).toBe('function');
      expect(onSubmit.mock.calls[1][2].values).toEqualMap({
        myField: 'autofilled value'
      }); // user edits field

      renderInput.mock.calls[1][0].input.onChange('user value'); // check field

      expect(renderInput).toHaveBeenCalled();
      expect(renderInput).toHaveBeenCalledTimes(4);
      expect(renderInput.mock.calls[3][0].input.value).toBe('user value');
      expect(renderInput.mock.calls[3][0].meta.autofilled).toBe(false); // why not test submitting again?

      _testUtils.default.Simulate.submit(form);

      expect(onSubmit).toHaveBeenCalledTimes(3);
      expect(onSubmit.mock.calls[2][0]).toEqualMap({
        myField: 'user value'
      });
      expect(typeof onSubmit.mock.calls[2][1]).toBe('function');
      expect(onSubmit.mock.calls[2][2].values).toEqualMap({
        myField: 'user value'
      });
    });
    it('should not reinitialize values on remount if destroyOnMount is false', function () {
      var store = makeStore({});
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var initialValues = {
        foo: 'fooInitial'
      };

      var Form =
      /*#__PURE__*/
      function (_Component58) {
        _inheritsLoose(Form, _Component58);

        function Form() {
          return _Component58.apply(this, arguments) || this;
        }

        var _proto58 = Form.prototype;

        _proto58.render = function render() {
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender,
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        destroyOnUnmount: false
      })(Form);

      var Container =
      /*#__PURE__*/
      function (_Component59) {
        _inheritsLoose(Container, _Component59);

        function Container() {
          var _this34;

          _this34 = _Component59.call(this) || this;
          _this34.state = {
            showForm: true
          };
          return _this34;
        }

        var _proto59 = Container.prototype;

        _proto59.render = function render() {
          var _this35 = this;

          var showForm = this.state.showForm;
          return _react.default.createElement("div", null, showForm && _react.default.createElement(Decorated, {
            initialValues: initialValues
          }), _react.default.createElement("button", {
            onClick: function onClick() {
              return _this35.setState({
                showForm: !showForm
              });
            }
          }, "Toggle Form"));
        };

        return Container;
      }(_react.Component);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Container, null))); // initialized form state


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            initial: {
              foo: 'fooInitial'
            },
            values: {
              foo: 'fooInitial'
            },
            registeredFields: {
              foo: {
                name: 'foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }); // rendered with initial value

      expect(inputRender).toHaveBeenCalled();
      expect(inputRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(inputRender, 1).input.value).toBe('fooInitial'); // change value

      inputRender.mock.calls[1][0].input.onChange('fooChanged'); // updated form state

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            initial: {
              foo: 'fooInitial'
            },
            values: {
              foo: 'fooChanged'
            },
            registeredFields: {
              foo: {
                name: 'foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }); // rendered with changed value

      expect(inputRender).toHaveBeenCalledTimes(3);
      expect(propsAtNthRender(inputRender, 2).input.value).toBe('fooChanged'); // unmount form

      var toggle = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'button');

      _testUtils.default.Simulate.click(toggle); // form state not destroyed (just fields unregistered)


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            initial: {
              foo: 'fooInitial'
            },
            values: {
              foo: 'fooChanged'
            },
            registeredFields: {
              foo: {
                name: 'foo',
                type: 'Field',
                count: 0
              }
            }
          }
        }
      }); // mount form

      _testUtils.default.Simulate.click(toggle); // form state not overwritten (fields re-registered)


      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            initial: {
              foo: 'fooInitial'
            },
            values: {
              foo: 'fooChanged'
            },
            registeredFields: {
              foo: {
                name: 'foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      }); // input rendered with changed value

      expect(inputRender).toHaveBeenCalledTimes(4);
      expect(propsAtNthRender(inputRender, 3).input.value).toBe('fooChanged');
    });
    it('should provide dispatch-bound blur() that modifies values', function () {
      var store = makeStore({});
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component60) {
        _inheritsLoose(Form, _Component60);

        function Form() {
          return _Component60.apply(this, arguments) || this;
        }

        var _proto60 = Form.prototype;

        _proto60.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              foo: {
                name: 'foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(typeof formRender.mock.calls[0][0].blur).toBe('function');
      formRender.mock.calls[0][0].blur('foo', 'newValue'); // check modified state

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              foo: {
                name: 'foo',
                type: 'Field',
                count: 1
              }
            },
            values: {
              foo: 'newValue'
            },
            fields: {
              foo: {
                touched: true
              }
            },
            anyTouched: true
          }
        }
      }); // rerendered again because now dirty

      expect(formRender).toHaveBeenCalledTimes(2);
    });
    it('should provide dispatch-bound change() that modifies values', function () {
      var store = makeStore({});
      var formRender = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component61) {
        _inheritsLoose(Form, _Component61);

        function Form() {
          return _Component61.apply(this, arguments) || this;
        }

        var _proto61 = Form.prototype;

        _proto61.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              foo: {
                name: 'foo',
                type: 'Field',
                count: 1
              }
            }
          }
        }
      });
      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(typeof formRender.mock.calls[0][0].change).toBe('function');
      formRender.mock.calls[0][0].change('foo', 'newValue'); // check modified state

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            registeredFields: {
              foo: {
                name: 'foo',
                type: 'Field',
                count: 1
              }
            },
            values: {
              foo: 'newValue'
            }
          }
        }
      }); // rerendered again because now dirty

      expect(formRender).toHaveBeenCalledTimes(2);
    });
    it('startSubmit in onSubmit promise', function () {
      var store = makeStore({});

      var Form =
      /*#__PURE__*/
      function (_Component62) {
        _inheritsLoose(Form, _Component62);

        function Form() {
          return _Component62.apply(this, arguments) || this;
        }

        var _proto62 = Form.prototype;

        _proto62.render = function render() {
          var handleSubmit = this.props.handleSubmit;
          return _react.default.createElement("form", {
            onSubmit: handleSubmit
          }, _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var resolvedProm = Promise.resolve();
      var Decorated = reduxForm({
        form: 'testForm',
        destroyOnUnmount: false,
        onSubmit: function onSubmit(data, dispatch) {
          dispatch(startSubmit('testForm'));
          return resolvedProm;
        }
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      }))); // unmount form


      ref.current.submit();
      return resolvedProm.then(function () {
        // form state not destroyed (just fields unregistered)
        expect(store.getState()).toEqualMap({
          form: {
            testForm: {
              anyTouched: true,
              fields: {
                foo: {
                  touched: true
                }
              },
              registeredFields: {
                foo: {
                  name: 'foo',
                  type: 'Field',
                  count: 1
                }
              },
              submitSucceeded: true
            }
          }
        });
      });
    });
    it('startSubmit in onSubmit sync', function () {
      var store = makeStore({});

      var Form =
      /*#__PURE__*/
      function (_Component63) {
        _inheritsLoose(Form, _Component63);

        function Form() {
          return _Component63.apply(this, arguments) || this;
        }

        var _proto63 = Form.prototype;

        _proto63.render = function render() {
          var handleSubmit = this.props.handleSubmit;
          return _react.default.createElement("form", {
            onSubmit: handleSubmit
          }, _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        destroyOnUnmount: false,
        onSubmit: function onSubmit(data, dispatch) {
          dispatch(startSubmit('testForm'));
        }
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      }))); // submit form


      ref.current.submit(); // form state not destroyed (just fields unregistered)

      expect(store.getState()).toEqualMap({
        form: {
          testForm: {
            anyTouched: true,
            fields: {
              foo: {
                touched: true
              }
            },
            registeredFields: {
              foo: {
                name: 'foo',
                type: 'Field',
                count: 1
              }
            },
            submitting: true,
            submitSucceeded: true
          }
        }
      });
    });
    it('submits even if submit errors exist', function () {
      var store = makeStore({});
      var count = 0;
      var onSubmit = jest.fn(function () {
        return new Promise(function (resolve) {
          count++;

          if (count === 1) {
            // first time throw exception
            throw new _SubmissionError.default({
              _error: 'Bad human!'
            });
          }

          resolve();
        });
      });
      var renderSpy = jest.fn(function () {});

      var Form =
      /*#__PURE__*/
      function (_Component64) {
        _inheritsLoose(Form, _Component64);

        function Form() {
          return _Component64.apply(this, arguments) || this;
        }

        var _proto64 = Form.prototype;

        _proto64.render = function render() {
          var _this$props = this.props,
              handleSubmit = _this$props.handleSubmit,
              error = _this$props.error,
              valid = _this$props.valid;
          renderSpy(valid, error);
          return _react.default.createElement("form", {
            onSubmit: handleSubmit
          }, _react.default.createElement(Field, {
            name: "foo",
            component: "input",
            type: "text"
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: onSubmit
      })(Form);

      var ref = _react.default.createRef();

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        ref: ref
      })));

      expect(renderSpy).toHaveBeenCalled();
      expect(renderSpy).toHaveBeenCalledTimes(1);
      expect(renderSpy.mock.calls[0][0]).toBe(true);
      expect(renderSpy.mock.calls[0][1]).toBe(undefined);
      expect(onSubmit).not.toHaveBeenCalled(); // submit form

      return ref.current.submit().then(function () {
        expect(onSubmit).toHaveBeenCalled();
        expect(onSubmit).toHaveBeenCalledTimes(1);
        expect(renderSpy).toHaveBeenCalledTimes(4);
        expect(renderSpy.mock.calls[3][0]).toBe(false);
        expect(renderSpy.mock.calls[3][1]).toBe('Bad human!');
      }).then(function () {
        return ref.current.submit();
      }) // call submit again!
      .then(function () {
        expect(onSubmit).toHaveBeenCalledTimes(2);
        expect(renderSpy).toHaveBeenCalledTimes(7);
        expect(renderSpy.mock.calls[5][0]).toBe(true);
        expect(renderSpy.mock.calls[5][1]).toBe(undefined);
      });
    });
    it('submits (via config) when the SUBMIT action is dispatched', function () {
      var logger = jest.fn(function (state) {
        if (state === void 0) {
          state = {};
        }

        return state;
      });
      var store = makeStore({}, logger);
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var onSubmit = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component65) {
        _inheritsLoose(Form, _Component65);

        function Form() {
          return _Component65.apply(this, arguments) || this;
        }

        var _proto65 = Form.prototype;

        _proto65.render = function render() {
          var handleSubmit = this.props.handleSubmit;
          return _react.default.createElement("form", {
            onSubmit: handleSubmit
          }, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: onSubmit
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      var callIndex = logger.mock.calls.length; // update input

      inputRender.mock.calls[0][0].input.onChange('hello'); // check that change action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(change('testForm', 'foo', 'hello', false, false)); // dispatch submit action

      store.dispatch(submit('testForm')); // check that submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(submit('testForm')); // check that clear submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(clearSubmit('testForm')); // check that touch action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(touch('testForm', 'foo')); // check that submit succeeded action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(setSubmitSucceeded('testForm')); // check no additional actions dispatched

      expect(logger).toHaveBeenCalledTimes(callIndex);
      expect(onSubmit).toHaveBeenCalled();
      expect(onSubmit).toHaveBeenCalledTimes(1);
      expect(onSubmit.mock.calls[0][0]).toEqualMap({
        foo: 'hello'
      });
      expect(typeof onSubmit.mock.calls[0][1]).toBe('function');
      expect(onSubmit.mock.calls[0][2].values).toEqualMap({
        foo: 'hello'
      });
    });
    it('submits (via prop) when the SUBMIT action is dispatched', function () {
      var logger = jest.fn(function (state) {
        if (state === void 0) {
          state = {};
        }

        return state;
      });
      var store = makeStore({}, logger);
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var onSubmit = jest.fn();

      var Form =
      /*#__PURE__*/
      function (_Component66) {
        _inheritsLoose(Form, _Component66);

        function Form() {
          return _Component66.apply(this, arguments) || this;
        }

        var _proto66 = Form.prototype;

        _proto66.render = function render() {
          var handleSubmit = this.props.handleSubmit;
          return _react.default.createElement("form", {
            onSubmit: handleSubmit
          }, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm'
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        onSubmit: onSubmit
      })));

      var callIndex = logger.mock.calls.length; // update input

      inputRender.mock.calls[0][0].input.onChange('hello'); // check that change action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(change('testForm', 'foo', 'hello', false, false)); // dispatch submit action

      store.dispatch(submit('testForm')); // check that submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(submit('testForm')); // check that clear submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(clearSubmit('testForm')); // check that touch action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(touch('testForm', 'foo')); // check that submit succeeded action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(setSubmitSucceeded('testForm')); // check no additional actions dispatched

      expect(logger).toHaveBeenCalledTimes(callIndex);
      expect(onSubmit).toHaveBeenCalled();
      expect(onSubmit).toHaveBeenCalledTimes(1);
      expect(onSubmit.mock.calls[0][0]).toEqualMap({
        foo: 'hello'
      });
      expect(typeof onSubmit.mock.calls[0][1]).toBe('function');
      expect(onSubmit.mock.calls[0][2].values).toEqualMap({
        foo: 'hello'
      });
    });
    it('does NOT submit (via config) invalid form when the SUBMIT action is dispatched', function () {
      var logger = jest.fn(function (state) {
        if (state === void 0) {
          state = {};
        }

        return state;
      });
      var store = makeStore({}, logger);
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var onSubmit = jest.fn();
      var formRender = jest.fn();

      var validate = function validate(values) {
        var errors = {};

        if (!getIn(values, 'foo')) {
          errors.foo = 'Required';
        }

        return errors;
      };

      var Form =
      /*#__PURE__*/
      function (_Component67) {
        _inheritsLoose(Form, _Component67);

        function Form() {
          return _Component67.apply(this, arguments) || this;
        }

        var _proto67 = Form.prototype;

        _proto67.render = function render() {
          formRender(this.props);
          var handleSubmit = this.props.handleSubmit;
          return _react.default.createElement("form", {
            onSubmit: handleSubmit
          }, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        onSubmit: onSubmit,
        validate: validate
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      var callIndex = logger.mock.calls.length; // form renders before sync validation and then again with invalid flag

      expect(formRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(formRender, 0).invalid).toBe(false);
      expect(propsAtNthRender(formRender, 1).invalid).toBe(true);
      expect(propsAtNthRender(formRender, 1).submitFailed).toBe(false); // try to submit invalid form via dispatching submit action

      store.dispatch(submit('testForm')); // check that submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(submit('testForm')); // check that clear submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(clearSubmit('testForm')); // check that touch action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(touch('testForm', 'foo')); // check that setSubmitFailed action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(setSubmitFailed('testForm', 'foo')); // form rerendered twice, once with submit trigger, and then after submit failure

      expect(formRender).toHaveBeenCalledTimes(4);
      expect(propsAtNthRender(formRender, 3).invalid).toBe(true);
      expect(propsAtNthRender(formRender, 3).submitFailed).toBe(true); // update input

      inputRender.mock.calls[0][0].input.onChange('hello'); // check that change action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(change('testForm', 'foo', 'hello', false, false)); // check that updateSyncErrors action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(updateSyncErrors('testForm', {})); // rerendered once to flip dirty flag, and again to flip invalid flag

      expect(formRender).toHaveBeenCalledTimes(6);
      expect(propsAtNthRender(formRender, 3).dirty).toBe(false);
      expect(propsAtNthRender(formRender, 4).dirty).toBe(true);
      expect(propsAtNthRender(formRender, 4).invalid).toBe(true);
      expect(propsAtNthRender(formRender, 5).invalid).toBe(false);
      expect(propsAtNthRender(formRender, 5).submitFailed).toBe(true); // dispatch submit action on now valid form

      store.dispatch(submit('testForm')); // check that submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(submit('testForm')); // check that clear submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(clearSubmit('testForm')); // check that touch action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(touch('testForm', 'foo')); // check that submit succeeded action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(setSubmitSucceeded('testForm')); // check no additional actions dispatched

      expect(logger).toHaveBeenCalledTimes(callIndex);
      expect(onSubmit).toHaveBeenCalled();
      expect(onSubmit).toHaveBeenCalledTimes(1);
      expect(onSubmit.mock.calls[0][0]).toEqualMap({
        foo: 'hello'
      });
      expect(typeof onSubmit.mock.calls[0][1]).toBe('function');
      expect(onSubmit.mock.calls[0][2].values).toEqualMap({
        foo: 'hello'
      });
    });
    it('does NOT submit (via prop) invalid form when the SUBMIT action is dispatched', function () {
      var logger = jest.fn(function (state) {
        if (state === void 0) {
          state = {};
        }

        return state;
      });
      var store = makeStore({}, logger);
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();
      var onSubmit = jest.fn();

      var validate = function validate(values) {
        var errors = {};

        if (!getIn(values, 'foo')) {
          errors.foo = 'Required';
        }

        return errors;
      };

      var Form =
      /*#__PURE__*/
      function (_Component68) {
        _inheritsLoose(Form, _Component68);

        function Form() {
          return _Component68.apply(this, arguments) || this;
        }

        var _proto68 = Form.prototype;

        _proto68.render = function render() {
          formRender(this.props);
          var handleSubmit = this.props.handleSubmit;
          return _react.default.createElement("form", {
            onSubmit: handleSubmit
          }, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        validate: validate
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, {
        onSubmit: onSubmit
      })));

      var callIndex = logger.mock.calls.length; // form renders before sync validation and then again with invalid flag

      expect(formRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(formRender, 0).invalid).toBe(false);
      expect(propsAtNthRender(formRender, 1).invalid).toBe(true);
      expect(propsAtNthRender(formRender, 1).submitFailed).toBe(false); // try to submit invalid form via dispatching submit action

      store.dispatch(submit('testForm')); // check that submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(submit('testForm')); // check that clear submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(clearSubmit('testForm')); // check that touch action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(touch('testForm', 'foo')); // check that setSubmitFailed action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(setSubmitFailed('testForm', 'foo')); // form rerendered twice, once with submit trigger, and then after submit failure

      expect(formRender).toHaveBeenCalledTimes(4);
      expect(propsAtNthRender(formRender, 3).invalid).toBe(true);
      expect(propsAtNthRender(formRender, 3).submitFailed).toBe(true); // update input

      inputRender.mock.calls[0][0].input.onChange('hello'); // check that change action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(change('testForm', 'foo', 'hello', false, false)); // check that updateSyncErrors action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(updateSyncErrors('testForm', {})); // rerendered once to flip dirty flag, and again to flip invalid flag

      expect(formRender).toHaveBeenCalledTimes(6);
      expect(propsAtNthRender(formRender, 3).dirty).toBe(false);
      expect(propsAtNthRender(formRender, 4).dirty).toBe(true);
      expect(propsAtNthRender(formRender, 4).invalid).toBe(true);
      expect(propsAtNthRender(formRender, 5).invalid).toBe(false);
      expect(propsAtNthRender(formRender, 5).submitFailed).toBe(true); // dispatch submit action on now valid form

      store.dispatch(submit('testForm')); // check that submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(submit('testForm')); // check that clear submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(clearSubmit('testForm')); // check that touch action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(touch('testForm', 'foo')); // check that submit succeeded action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(setSubmitSucceeded('testForm')); // check no additional actions dispatched

      expect(logger).toHaveBeenCalledTimes(callIndex);
      expect(onSubmit).toHaveBeenCalled();
      expect(onSubmit).toHaveBeenCalledTimes(1);
      expect(onSubmit.mock.calls[0][0]).toEqualMap({
        foo: 'hello'
      });
      expect(typeof onSubmit.mock.calls[0][1]).toBe('function');
      expect(onSubmit.mock.calls[0][2].values).toEqualMap({
        foo: 'hello'
      });
    });
    it('should allow initialize on componentWillMount with sync validation', function () {
      var logger = jest.fn(function (state) {
        if (state === void 0) {
          state = {};
        }

        return state;
      });
      var store = makeStore({}, logger);
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var formRender = jest.fn();

      var validate = function validate(values) {
        var errors = {};

        if (!getIn(values, 'foo')) {
          errors.foo = 'Required';
        }

        return errors;
      };

      var Form =
      /*#__PURE__*/
      function (_Component69) {
        _inheritsLoose(Form, _Component69);

        function Form() {
          return _Component69.apply(this, arguments) || this;
        }

        var _proto69 = Form.prototype;

        _proto69.componentWillMount = function componentWillMount() {
          this.props.initialize({
            foo: 'Initialized'
          });
        };

        _proto69.render = function render() {
          formRender(this.props);
          return _react.default.createElement("form", null, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender
          }));
        };

        return Form;
      }(_react.Component);

      var Decorated = reduxForm({
        form: 'testForm',
        validate: validate
      })(Form);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(Decorated, null)));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(3);
      expect(propsAtNthRender(formRender, 0).valid).toBe(true);
      expect(propsAtNthRender(formRender, 1).valid).toBe(false);
      expect(propsAtNthRender(formRender, 2).valid).toBe(true);
    });
  });
};

describeReduxForm('reduxForm.plain', _plain.default, _redux.combineReducers, function () {
  return expect.extend(_expectations2.default);
});
describeReduxForm('reduxForm.immutable', _immutable.default, _reduxImmutablejs.combineReducers, function () {
  return expect.extend(_expectations.default);
});